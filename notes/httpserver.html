<!DOCTYPE html>
<html>
    <head>
	<title>Tools</title>
	<link rel="stylesheet" type="text/css" href="external/css/bootstrap.css">
	<script type="text/javascript" src="./external/js/bootstrap.js" rel="javascript"></script>
    <script type="text/javascript" src="external/js/jquery.min.js" rel="javascript"></script>
  
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.16.0/umd/popper.min.js"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js"></script>

	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
	<link href="https://fonts.googleapis.com/css?family=Courier+Prime&display=swap" rel="stylesheet">
	<link rel="stylesheet" type="text/css" href="css/main.css">
	<meta charset="utf-8">
    <!--meta http-equiv="refresh" content="3.9"-->
</head>
<body>


 <nav class="navbar navbar-expand-lg navbar-dark bg-dark">
  <a class="navbar-brand" href="#">Phil Full-Stack Notes</a>
  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarTogglerDemo02" aria-controls="navbarTogglerDemo02" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

  <div class="collapse navbar-collapse" id="navbarTogglerDemo02">
    <ul class="navbar-nav mr-auto mt-2 mt-lg-0">
        
      <li class="nav-item active">
        <a class="nav-link" href="index.html">Home <span class="sr-only">(current)</span></a>
      </li>
        
      <li class="nav-item">
        <a class="nav-link" href="terminal.html">Terminal</a>
      </li>
        
        <li class="nav-item">
        <a class="nav-link" href="git.html">Git VCS</a>
      </li>
        
         <li class="nav-item">
        <a class="nav-link" href="database.html">Database</a>
      </li>
        
        <!-- Dropdown -->
    <li class="nav-item dropdown">
      <a class="nav-link dropdown-toggle" href="#" id="navbardrop" data-toggle="dropdown">
        Tools
      </a>
      <div class="dropdown-menu">
        <a class="dropdown-item" href="sql.html">SQL </a>
        <a class="dropdown-item" href="#">Boostrap 4</a>
        <a class="dropdown-item" href="#">Javascript</a>
        <a class="dropdown-item" href="httpprotocol.html">HTTP Protocol</a>
        <a class="dropdown-item" href="httpserver.html">HTTP Server</a>
      </div>
    </li>
        
         <li class="nav-item">
        <a class="nav-link" href="github.html">Git Hub</a>
      </li>
        
    </ul>
      
    <form class="form-inline my-2 my-lg-0">
      <input class="form-control mr-sm-2" type="search" placeholder="Search">
      <button class="btn btn-outline-success my-2 my-sm-0" type="submit">Search</button>
    </form>
  </div>
</nav>
    
<div class="jumbotron">
<div>
	<h1>HTTP SERVER</h1>
	<h3 class="notes">An introduction to the Web from Python </h3>
    
        <div>
    <hr>
    
    </div>
    <div>
        
        <h3> Learning Objectives</h3>
        
        <ul>
            <li> Practise with http.server Python Module.</li>
            <li>Use encode() to send data from the server.</li>
            <li>Explain quies and quoting as a way to send data in a request. </li>
            <li>Differentiate a GET Request from a POST Request</li>
            <li>Demonstrate Post-Redirect-Get</li>
            <li>Define JSON</li>
        </ul>
        
    </div>
    
    <div>
    <hr>
    
    </div>
    
    
	</div>
		
    	<div class="card text-white bg-danger mb-3" style="max-width: 30rem;">
		  <div class=" ">
		  	<div class="card-header">>_. http.server Python's Module
			  	<i class="fa fa-circle theIcon01" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon02" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon03" style="font-size:20px"></i>
		  	  </div>
		     </div>
		 	 <div class="card-body">
                 <h2> http.server</h2>
		     <p> http.server module defines classes for implementing HTTP servers (Web servers).</p>
             
                 <blockquote class="blockquote">Note: http.server is not recommended for production. It only implements basic security checks. But it is a first step to understand the lower level behavior of a Web server.</blockquote>
                 
                 <hr>
		     <p class="card-text">These modules are written in object-oriented Python. You should already be familiar with creating class instances, defining subclasses, and defining methods on classes.</p>

                 <p>If you need a refresher on the Python syntax for these object-oriented actions, you might want to browse:</p>
             
            <div class="theButton">  <button type="button" class="btn-lg btn-danger active "aria-pressed="true"><a href="https://docs.python.org/3/tutorial/classes.html" class="theButton" target="_blank">PYTHON CLASSES </a></button> </div>
                 
                 
            <div class="theButton">  <button type="button" class="btn-lg btn-danger active "aria-pressed="true"><a href="https://classroom.udacity.com/courses/ud036/lessons/990110642/concepts/10079185740923" class="theButton" target="_blank">PYTHON </a></button> </div>
                
		</div>
	</div>
    
    
    
    
    
		<div class="card text-white bg-dark mb-3" style="max-width: 30rem;">
		  <div class=" ">
		  	<div class="card-header">Servers and handlers
			  	<i class="fa fa-circle theIcon01" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon02" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon03" style="font-size:20px"></i>
		  	  </div>
		     </div>
		 	 <div class="card-body">
		     <h5 class="card-title theCode">Webserver and Client</h5>
		     <p class="card-text"> Web servers using http.server are made of two parts: the HTTPServer class, and a request handler class. The first part, the HTTPServer class, is built into the module and is the same for every web service. </p>
                 
            <p> It knows how to listen on a port and accept HTTP requests from clients. Whenever it receives a request, it hands that request off to the second part — a request handler — which is different for every web service.</p>
                 
            <p>Here's what your Python code will need to do in order to run a web service:</p>
                 
            <ul>
                <li>Import http.server, or at least the pieces of it that you need.</li>     
                <li>Create a subclass of http.server.BaseHTTPRequestHandler. This is your handler class.</li>     
                <li>Define a method on the handler class for each HTTP verb you want to handle. (The only HTTP verb you've seen yet in this course is GET, but that will be changing soon.)</li>   
                    <ul>
                        <li>The method for GET requests has to be called do_GET. </li>
                        <li>Inside the method, call built-in methods of the handler class to read the HTTP request and write the response </li>
                    </ul>
                <li>Create an instance of http.server.HTTPServer, giving it your handler class and server information — particularly, the port number.</li>     
                <li>Call the HTTPServer instance's serve_forever method.</li>     
                 
                 
            </ul>

            <p>Once you call the HTTPServer instance's serve_forever method, the server does that — it runs forever until stopped.</p>
            <p>if you have a Python server running and you want to stop it, type Ctrl-C into the terminal where it's running. (You may need to type it two or three times.)</p>
		</div>
	</div>



	<div class="card text-white bg-dark mb-3" style="max-width: 30rem;">
		  <div class=" ">
		  	<div class="card-header">Exercise: Running a Web Server
			  	<i class="fa fa-circle theIcon01" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon02" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon03" style="font-size:20px"></i>
		  	  </div>
		     </div>
		 	 <div class="card-body">
		     <h5 class="card-title theCode">$python3 -m http.server 8000</h5>
		     <p class="card-text">from http.server import HTTPServer, BaseHTTPRequestHandler </p>

<p>class HelloHandler(BaseHTTPRequestHandler):</p>
    <p>def do_GET(self):</p>
       <p> # First, send a 200 OK response.</p>
       <p> self.send_response(200)</p>

       <p> # Then send headers.</p>
       <p> self.send_header('Content-type', 'text/plain; charset=utf-8')</p>
       <p> self.end_headers()</p>

       <p> # Now, write the response body.</p>
        <p>self.wfile.write("Hello, HTTP!\n".encode())</p>

<p>if __name__ == '__main__':</p>
   <p> server_address = ('', 8000)  # Serve on all addresses, port 8000.</p>
   <p> httpd = HTTPServer(server_address, HelloHandler)</p>
   <p> httpd.serve_forever()</p>
                 
            <ul>
                <li class="theCode">from http.server import HTTPServer, BaseHTTPRequestHandler</li>
               <li> The http.server module has a lot of parts in it. For now, this program only needs these two. I'm using the from syntax of import so that I don't have to type http.server over and over in my code..</li>

                <li class="theCode">class HelloHandler(BaseHTTPRequestHandler):</li>
                    <ul>
                    <li class="theCode">def do_GET(self):</li>
                </ul>
                <li>This is the handler class. It inherits from the BaseHTTPRequestHandler parent class, which is defined in http.server. I've defined one method, do_GET, which handles HTTP GET requests. When the web server receives a GET request, it will call this method to respond to it.</li>
                

                <li>As you saw in the previous lesson, there are three things the server needs to send in an HTTP response: a status code, some headers, and the response body. The handler parent class has methods for doing each of these things. Inside do_GET, I just call them in order.</li> 
                 
                <ul>
                    <li class="theCode"> self.send_response(200)</li>
                </ul>
                
                <li>The first thing the server needs to do is send a 200 OK status code; and the send_response method does this. I don't have to tell it that 200 means OK; the parent class already knows that.</li>
                
                  <ul>
                    <li class="theCode"> self.send_header('Content-type', 'text/plain; charset=utf-8')
                    </li>
                    <li class="theCode"> self.end_headers()</li>
                </ul>
                
                <li>The next thing the server needs to do is send HTTP headers. The parent class supplies the send_header and end_headers methods for doing this. For now, I'm just having the server send a single header line — the Content-type header telling the client that the response body will be in UTF-8 plain text.
                </li>
                
                
                <ul>
                    <li class="theCode"> self.wfile.write("Hello, HTTP!\n".encode())</li>
                </ul>
                
                <li>The last part of the do_GET method writes the response body.</li>
                
                
                <li>The parent class gives us a variable called self.wfile, which is used to send the response. The name wfile stands for writeable file. Python, like many other programming languages, makes an analogy between network connections and open files: they're things you can read and write data to. Some file objects are read-only; some are write-only; and some are read/write.</li>
                
                <li>self.wfile represents the connection from the server to the client; and it is write-only; hence the name. Any binary data written to it with its write method gets sent to the client as part of the response. Here, I'm writing a friendly hello message.</li>
                
                
                <li>What's going on with .encode() though? We'll get to that in a moment. Let's look at the rest of the code first.</li>
                
                <li class="theCode">if __name__ == '__main__': </li>
                    <ul>
                        <li class="theCode"> server_address = ('', 8000)</li>
                        <li class="theCode">httpd = HTTPServer(server_address, HelloHandler)</li>
                        <li class="theCode">httpd.serve_forever()</li>                    
                    </ul>
                
               <li>This code will run when we run this module as a Python program, rather than importing it. The HTTPServer constructor needs to know what address and port to listen on; it takes these as a tuple that I'm calling server_address. I also give it the HelloHandler class, which it will use to handle each incoming client request.</li>
                
                <li>At the very end of the file, I call serve_forever on the HTTPServer, telling it to start handling HTTP requests. And that starts the web server running.</li>
                
                 </ul>
            
                 <p>When you start up the demo server, it will print a message telling you that it's serving HTTP. Leave it running, and leave the terminal open. Now try accessing <strong class="theCode">http://localhost:8000/</strong> from your browser.</p>
		</div>
	</div>

	<div class="card text-white bg-dark mb-3" style="max-width: 30rem;">
		  <div class=" ">
		  	<div class="card-header">.encode() 
			  	<i class="fa fa-circle theIcon01" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon02" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon03" style="font-size:20px"></i>
		  	  </div>
		     </div>
		 	 <div class="card-body">
		     <h5 class="card-title theCode">self.wfile.write("Hello, HTTP!\n".encode())
 </h5>
                 <p class="card-text ">An HTTP response could contain any kind of data, not only text. And so the self.wfile.write method in the handler class expects to be given a bytes object — a piece of arbitrary binary data — which it writes over the network in the HTTP response body.</p>

                 <p>If you want to send a string over the HTTP connection, you have to encode the string into a bytes object. The encode method on strings translates the string into a bytes object, which is suitable for sending over the network. There is, similarly, a decode method for turning bytes objects into strings.</p>

                 <p>Text strings look simple, but they are actually kind of complicated underneath. There are a lot of different ways that computers can represent text in memory and on the network.</p>
                 
                 <p>lder software — including older versions of Python — tended to assume that each character takes up only one byte of memory. That works fine for some human languages, like English and Russian, but it doesn't work at all for other human languages, like Chinese; and it really doesn't work if you want to handle text from multiple languages in the same program.</p>
                 
                 <p>The Web is international, so browsers and servers need to support all languages. This means that the old one-byte assumption is completely thrown out. But when programs use the network, they need to know how long a piece of data is in terms of bytes. That has to be figured out unambiguously at some point in time. The way Python does this is by making us encode strings into bytes objects when we want to send them over a binary channel (such as an HTTP connection).</p>
                 
                 <p>UTF-8 is the default encoding in Python. When you call the encode method on a string without passing it another encoding, it assumes you mean UTF-8. This is the right thing to do, so that's what the code in this course does.</p>
                 
                 <a href="https://docs.python.org/3.6/howto/unicode.html" target="_blank"><button type="button" class="btn-lg btn-danger "s>UNICODE</button></a>
		</div>
	</div>
		
		<div class="card text-white bg-dark mb-3" style="max-width: 30rem;">
		  <div class=" ">
		  	<div class="card-header">  Path
			  	<i class="fa fa-circle theIcon01" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon02" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon03" style="font-size:20px"></i>
		  	  </div>
		     </div>
		 	 <div class="card-body">
		     
		     <p class="card-text">The only difference in the code between EchoHandler and HelloHandler is what they write in the response body. The hello server always writes the same message, while the echo server takes its message from the request path. Here's how I did it — a one-line change at the end of do_GET:</p>
                 
                 <h5 class="card-title theCode">$self.wfile.write(self.path[1:].encode())</h5>
                 
                 <p>What I'm doing here is taking the path (for instance "/bears"), using a string slice to remove the first character (which is always a slash), and then encoding the resulting string into bytes, then writing that to the HTTP response body.</p>

                 <p>message = self.path[1:]  # Extract 'bears' from '/bears', for instance </p>
                 <p>message_bytes = message.encode()  # Make bytes from the string</p>
                 <p>self.wfile.write(message_bytes)  # Send it over the network</p>

			</div>
		</div>
		
		<div class="card text-white bg-dark mb-3" style="max-width: 30rem;">
		  <div class=" ">
		  	<div class="card-header">Queries and quoting
			  	<i class="fa fa-circle theIcon01" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon02" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon03" style="font-size:20px"></i>
		  	  </div>
		     </div>
		 	 <div class="card-body">
		     <h5 class="card-title theCode">Unpacking query parameters </h5>

		      <p class="card-text">When you take a look at a URI for a major web service, you'll often see several query parameters, which are a sort of variable assignment that occurs after a ? in the URI. For instance, here's a Google Image Search URI:</p>
                 
                 <a href="#" class="theCode">https://www.google.com/search?q=gray+squirrel&tbm=isch</a>

                 <p> This will be sent to the web server as this HTTP request:</p>
                 
                 <p class="theCode">GET /search?q=gray+squirrel&tbm=isch HTTP/1.1</p>
                 <p class="theCode">Host: www.google.com</p>
                 
                 <p>The query part of the URI is the part after the ? mark. Conventionally, query parameters are written as key=value and separated by <strong class="theCode">&amp;</strong> signs. So the above URI has two query parameters, q and tbm, with the values gray+squirrel and isch.</p>
                 
                 <p>(isch stands for Image Search.)</p>
                 
                 <p>There is a Python library called urllib.parse that knows how to unpack query parameters and other parts of an HTTP URL. (The library doesn't work on all URIs, only on some URLs.)</p>
                 
                 <a href="https://docs.python.org/3/library/urllib.parse.html" target="_blank"><button type="button" class="btn-lg btn-danger "s>urllib.parse</button></a>
                 
                 
                 <p>A query parameter may show up multiple times in the query string, so parse_qs returns a dictionary of lists with all the values it's associated with.</p>
                 
                 <p class="theCode">>>> from urllib.parse import urlparse, parse_qs</p>
                 <p class="theCode">>>> address = 'https://www.google.com/search?q=gray+squirrel&tbm=isch'</p>
                 <p class="theCode">>>> parts = urlparse(address)</p>
                 <p class="theCode">>>> print(parts)</p>
                 
                 <p>As a result you will get:</p>
                 
                 <blockquote class="blockquote">
                 ParseResult(scheme='https', netloc='www.google.com', path='/search', params='', query='q=gray+squirrel&tbm=isch', fragment='')
                 </blockquote>
                 
                 <p>Then</p>
                 
                 <p class="theCode">>>> print(parts.query)</p>
                 
                 <p>And will get:</p>
                 <blockquote class="blockquote">
                 q=gray+squirrel&tbm=isch
                 </blockquote>
                 
                 
                 <p class="theCode">>>>query = parse_qs(parts.query)</p>
                 <p class="theCode">>>> query </p>
                 <p class="theCode">{'q': ['gray squirrel'], 'tbm': ['isch']}</p>
                 
                  <p> As a result, you are getting a dictionary with the values passed in the Url:</p>

                  <blockquote class="blockquote">{'q': ['gray squirrel'], 'tbm': ['isch']}</blockquote>
                 
                 <p>If you want to read each parameter you can use:</p>
                 
                 <p class="theCode">>>>query['q']</p>
                 
                 <p>To get as the result: ['gray squirrel']</p>
                 
                 
                 

		</div>
	</div>

	<div class="card text-white bg-dark mb-3" style="max-width: 30rem;">
		  <div class=" ">
		  	<div class="card-header"> URI Quoting
			  	<i class="fa fa-circle theIcon01" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon02" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon03" style="font-size:20px"></i>
		  	  </div>
		     </div>
		 	 <div class="card-body">
		     <h5 class="card-title">URI Quoting </h5>
		     <p class="card-text">Did you notice that 'gray+squirrel' in the query string became 'gray squirrel' in the output of parse_qs?</p>
                 
                 <p>HTTP URLs aren't allowed to contain spaces or certain other characters. So if you want to send these characters in an HTTP request, they have to be translated into a "URL-safe" or "URL-quoted" format.</p>

                 <p>"Quoting" in this sense doesn't have to do with quotation marks, the kind you find around Python strings. It means translating a string into a form that doesn't have any special characters in it, but in a way that can be reversed (unquoted) later.</p>

                 <p>(And if that isn't confusing enough, it's sometimes also referred to as URL-encoding or URL-escaping).</p>

                 <p>One of the features of the URL-quoted format is that spaces are sometimes translated into plus signs. Other special characters are translated into hexadecimal codes that begin with the percent sign.</p>

                 <p>Take a look at the documentation for urllib.parse.quote and related functions.</p>

                <p>Later in the course when you want to construct a URI in your code, you'll need to use appropriate quoting. More generally, whenever you're working on a web application and you find spaces or percent-signs in places you don't expect them to be, it means that something needs to be quoted or unquoted. </p>

			</div>
		</div>

	<div class="card text-white bg-dark mb-3" style="max-width: 30rem;">
		  <div class=" ">
		  	<div class="card-header">POST METHOD
			  	<i class="fa fa-circle theIcon01" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon02" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon03" style="font-size:20px"></i>
		  	  </div> 
		     </div>
		 	 <div class="card-body">
		     <h5 class="card-title theCode">Form methods: GET and POST </h5>
		     <p class="card-text">In the last lesson, I mentioned that GET is only one of many HTTP verbs or methods.</p>

                 <p>When a browser submits a form via GET, it puts all of the form fields into the URI that it sends to the server. These are sent as a query, in the request path — just like search engines do. They're all jammed together into a single line. Since they're in the URI, the user can bookmark the resulting page, reload it, and so forth.
		      </p>
                 
                 <p>This is fine for search engine queries, but it's not quite what we would want for (say) a form that adds an item to your shopping cart on an e-commerce site, or posts a new message on a comments board. GET methods are good for search forms and other actions that are intended to look something up or ask the server for a copy of some resource. But GET is not recommended for actions that are intended to alter or create a resource. For this sort of action, HTTP has a different verb, POST.</p>
                 
                <h3>Idempotence</h3>

                 
                 <blockquote class="blockquote">
                    <p>Vocabulary word of the day: idempotent. An action is idempotent if doing it twice (or more) produces the same result as doing it once. "Show me the search results for 'polar bear'" is an idempotent action, because doing it a second time just shows you the same results. "Add a polar bear to my shopping cart" is not, because if you do it twice, you end up with two polar bears.</p>

                    <p> POST requests are not idempotent. If you've ever seen a warning from your browser asking you if you really mean to resubmit a form, what it's really asking is if you want to do a non-idempotent action a second time.</p>
                 
                 </blockquote>
                 
                 <p>(Important note if you're ever asked about this in a job interview: idempotent is pronounced like "eye-dem-poe-tent", or rhyming with "Hide 'em, Joe Tent" — not like "id impotent".)</p>
                 
                 <p>When a browser submits a form as a POST request, it doesn't encode the form data in the URI path, the way it does with a GET request. Instead, it sends the form data in the request body, underneath the headers. The request also includes Content-Type and Content-Length headers, which we've previously only seen on HTTP responses.</p>
                 
                 <blockquote class="blockquote">By the way, the names of HTTP headers are case-insensitive. So there's no difference between writing Content-Length or content-length or even ConTent-LeNgTh … except, of course, that humans will read your code and be confused by that last one.</blockquote>

			</div>
		</div>
    
    <div class="card text-white bg-dark mb-3" style="max-width: 30rem;">
		  <div class=" ">
		  	<div class="card-header">A server for POST
			  	<i class="fa fa-circle theIcon01" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon02" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon03" style="font-size:20px"></i>
		  	  </div>
		     </div>
		 	 <div class="card-body">
		     <h5 class="card-title theCode">A server for POST </h5>
                 <p class="card-text">n the next few exercises, you'll be building a messageboard server. </p>

                 <p>When a user goes to the main page in their browser, it'll display a form for writing messages, as well as a list of the previously written messages.</p>

                 <p>Submitting the form will send a request to the server, which stores the submitted message and then re-displays the main page.</p>

                 <p>In order to test your messageboard server, you'll need to install the requests module, which is a Python module for making HTTP requests.</p>

                <p>We'll see much more about this module later in this lesson. For now, just run <strong class="theCode">pip3 install requests</strong> in your terminal to install it.
		      </p>
                 
                 <p>We'll be using a GET request to display the messageboard's existing contents, and POST to update the contents by creating new messages. Creating new messages is not idempotent — we don't want duplicates.</p>
                 
                 
                 <h3>Why don't we want to use GET for submitting the form?</h3>
                 
                 <p> Imagine if a user did this. They write a message and press the submit button … and the message text shows up in their URL bar. If they press reload, it sends the message again. If they bookmark that URL and go back to it, it sends the message again.</p>

                 <p>This doesn't seem like such a great experience. So we'll use POST for message submission, and GET to display the main page.</p>
                 
                 <hr>
                 
                 <h3>POST handlers read the request body</h3>
                 
                 <p>Previously in the HelloServer exercise, you've written handler classes that have just a single method, do_GET.</p>

                 <p>But a handler class can have do_POST as well, to support GET and POST requests. This is exactly how the messageboard server will work.</p>

                 <p>When a GET request comes in, the server will send the HTML form and current messages. When a POST request comes in with a new message, the server will store the message in a list, and then return all the messages it's seen so far.</p>

                 <p>The code for a do_POST method will need to do some pretty different things from a do_GET method. When we're handling a GET request, all the user data in the request is in the URI path. But in a POST request, it's in the request body.</p>

                 <p>Inside do_POST, our code can read the request body by calling the self.rfile.read method. self.rfile is a file object, like the self.wfile we saw earlier — but rfile is for reading the request, rather than writing the response.</p>

                 <p>However, self.rfile.read needs to be told how many bytes to read … in other words, how long the request body is.</p>
                 
                <p>If there's a request body at all, the browser will send the length of the request body in the Content-Length header.</p>

			</div>
		</div>
    
    <div class="card text-white bg-dark mb-3" style="max-width: 30rem;">
		  <div class=" ">
		  	<div class="card-header">Headers are strings (or missing)
			  	<i class="fa fa-circle theIcon01" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon02" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon03" style="font-size:20px"></i>
		  	  </div>
		     </div>
		 	 <div class="card-body">
		     <h5 class="card-title theCode">Still under POST </h5>
		     <p class="card-text">The handler class gives us access to the HTTP headers as the instance variable self.headers, which is an object that acts a lot like a Python dictionary. The keys of this dictionary are the header names, but they're case-insensitive: it doesn't matter if you look up 'content-length' or 'Content-Length'. The values in this dictionary are strings: if the request body is 140 bytes long, the value of the Content-length entry will be the string "140". We need to call self.rfile.read(140) to read 140 bytes; so once we read the header, we'll need to convert it to an integer.</p>

                <p>But in an HTTP request, it's also possible that the body will be empty, in which case the browser might not send a Content-length header at all. This means we have to be a little careful when accessing the headers from the self.headers object. If we do self.headers['content-length'] and there's no such header, our code will crash with a KeyError. Instead, we'll use the .get dictionary method to get the header value safely.</p>

                 <p>So here's a little bit of code that can go in the do_POST handler to find the length of the request body and read it:
		      </p>
                 
                 <p class="theCode">length = int(self.headers.get('Content-length', 0))</p>
                <p class="theCode">data = self.rfile.read(length).decode()</p>
                 
                 <blockquote class="blockquote">
                 Once you read the message body, you can use urllib.parse.parse_qs to extract the POST parameters from it.
                 </blockquote>
                

			</div>
		</div>
    
    <div class="card text-white bg-dark mb-3" style="max-width: 30rem;">
		  <div class=" ">
		  	<div class="card-header">Post-Redirect-Get
			  	<i class="fa fa-circle theIcon01" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon02" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon03" style="font-size:20px"></i>
		  	  </div>
		     </div>
		 	 <div class="card-body">
		     <h5 class="card-title theCode"> &lt;a href="cliffsofinsanity.png"&gt;cliffsofinsanity.png&lt;/a&gt;</h5>
		     <p class="card-text">There's a very common design pattern for interactive HTTP applications and APIs, called the PRG or Post-Redirect-Get pattern. A client POSTs to a server to create or update a resource; on success, the server replies not with a 200 OK but with a 303 redirect. The redirect causes the client to GET the created or updated resource.</p>

             <p>This is just one of many, many ways to architect a web application, but it's one that makes good use of HTTP methods to accomplish specific goals. For instance, wiki sites such as Wikipedia often use Post-Redirect-Get when you edit a page.</p>
                 
            <p>For the messageboard server, Post-Redirect-Get means:</p>
            <ol>
                <li>You go to http://localhost:8000/ in your browser. Your browser sends a GET request to the server, which replies with a 200 OK and a piece of HTML. You see a form for posting comments, and a list of the existing comments. (But at the beginning, there are no comments posted yet.) </li>
                <li>You write a comment in the form and submit it. Your browser sends it via POST to the server.</li>
                <li>The server updates the list of comments, adding your comment to the list. Then it replies with a 303 redirect, setting the Location: / header to tell the browser to request the main page via GET.</li>
                <li>The redirect response causes your browser to go back to the same page you started with, sending a GET request, which replies with a 200 OK and a piece of HTML …</li>
                 
            </ol>
                <p>One big advantage of Post-Redirect-Get is that as a user, every page you actually see is the result of a GET request, which means you can bookmark it, reload it, and so forth — without ever accidentally resubmitting a form.</p>
                 
			</div>
		</div>
    
    
        <div class="card text-white bg-dark mb-3" style="max-width: 30rem;">
		  <div class=" ">
		  	<div class="card-header">Making requests
			  	<i class="fa fa-circle theIcon01" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon02" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon03" style="font-size:20px"></i>
		  	  </div>
		     </div>
		 	 <div class="card-body">
                <p class="theCode"> requests.get("http://localhost:8000/")</p>
                 
                 <p>The requests function for performing GET requests is requests.get, and it takes the URI as an argument.</p>
                 
                    <p>The requests library is a Python library for sending requests to web servers and interpreting the responses. It's not included in the Python standard library, though; you'll need to install it. In your terminal, run pip3 install requests to fetch and install the requests library.</p>
                 
		         <a href="https://2.python-requests.org//en/master/user/quickstart/" target="_blank"><button type="button" class="btn-lg btn-danger "s>Requests</button></a>
                <hr>
                
		     <p class="card-text">If you follow these links in your browser, it will fetch the same page from Wikipedia's web server. But the second one displays the page scrolled to the section about the discovery of oxygen. The part of the URI after the <strong class="theCode">#</strong> sign is called a <strong class="theCode">fragment</strong>. The browser doesn't even send it to the web server. It lets a link point to a specific named part of a resource; in HTML pages it links to an element by id.</p>
                 
                 <p>In contrast, consider this Google Search URI:</p>
                 
                 <ul>
                     <li class="theCode">>>> import requests
                     <li class="theCode">>>> a = requests.get("http://udacity.com")</li>
                     <li class="theCode">>>> a</li>
                     <li class="theCode">Response [200]</li>
                     <li class="theCode">>>> type(a)</li>
                     <li class="theCode"> class 'requests.models.Response'</li>            
                 </ul>
                 
                
                 <h3>r.content or r.text</h3>
                 <p>Both, but they're different. r.content is a bytes object representing the literal binary data that the server sent. r.text is the same data but interpreted as a str object, a Unicode string.</p>
                 
                 
                 <h3>Handling errors</h3>
                 
                 <p>If the requests.get call can reach an HTTP server at all, it will give you a Response object. If the request failed, the Response object has a status_code data member — either 200, or 404, or some other code.</p>

                 <p>But if it wasn't able to get to an HTTP server, for instance because the site doesn't exist, then requests.get should raise an exception.</p>

                 <p>However: Some Internet service providers will try to redirect browsers to an advertising site if you try to access a site that doesn't exist. This is called DNS hijacking, and it's nonstandard behavior, but some do it anyway. If your ISP hijacks DNS, you won't get exceptions when you try to access nonexistent sites. Standards-compliant DNS services such as Google Public DNS don't hijack.</p>
                 
			</div>
		</div>
    
    <div class="card text-white bg-dark mb-3" style="max-width: 30rem;">
		  <div class=" ">
		  	<div class="card-header">Using a JSON API
			  	<i class="fa fa-circle theIcon01" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon02" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon03" style="font-size:20px"></i>
		  	  </div>
		     </div>
		 	 <div class="card-body">
            <h5 class="card-title theCode">Using a JSON API </h5>
                 
                 <p>As a web developer, you will deal with data in a lot of different formats, especially when your code calls out to APIs provided by other developers. It's not uncommon for a large software system to have parts that deal with a dozen or more different data formats. Fortunately, usually, someone else has already written libraries to help you read and write these formats.</p>
                 
                 
		          <p class="card-text">JSON is a data format based on the syntax of JavaScript, often used for web-based APIs. There are a lot of services that let you send HTTP queries and get back structured data in JSON format. You can read more about the JSON format at http://www.json.org/.</p>

                 <p>Python has a built-in json module; and as it happens, the requests module makes use of it. A Response object has a .json method; if the response data is JSON, you can call this method to translate the JSON data into a Python dictionary.</p>

                 <p>Try it out! Here, I'm using it to access the Star Wars API, a classic JSON demonstration that contains information about characters and settings in the Star Wars movies:</p>
                 
                 <p class="theCode">>>> a = requests.get('http://swapi.co/api/people/1/')</p>
                 <p class="theCode">>>> a.json()['name']</p>
                 <p class="theCode">'Luke Skywalker'</p>
                 
                 <hr>
                 
                 <h2>Extract data from a JSON response</h2>
                 
                 <p>There's a great example of an API on the site http://uinames.com/, a service that makes up fake names and user account information. You can find the full API documentation under the little menu at the top right.</p>

                 <p>For this exercise, all you'll need is this URI and a couple of query parameters:</p>

                 <p class="theCode">http://uinames.com/api/</p>

                 <p>The query parameters to use are ext, which gives you a record with more fields, and region, which lets you specify which country you want your imaginary person to come from. For instance, to have the API invent a person from Italy:</p>

                 <p class="theCode">http://uinames.com/api?ext&region=Italy</p>

                 <p>(It's not perfect. For instance, currently it makes up North American phone numbers for everyone, regardless of where they live.)</p>
                 
                 <hr>
                 
                 <h2>Localhost</h2>
                 
                 <p> The IPv4 address 127.0.0.1 and the IPv6 address ::1 are special addresses that mean "this computer itself" — for when a client (like your browser) is accessing a server on your own computer. The hostname localhost refers to these special addresses.</p>
                 
                 <p>When you run the demo server, it prints a message saying that it's listening on 0.0.0.0. This is not a regular IP address. Instead, it's a special code for "every IPv4 address on this computer". That includes the localhost address, but it also includes your computer's regular IP address.</p>
                 
                 <blockquote class="blockquote">A single web server can have lots of different web sites running on it, each with their own hostname. When a client asks the server for a resource, it has to specify what hostname it intends to be talking to. </blockquote>
                 
                 <h2>Ports</h2>
                 
                 <p>When you told your browser to connect to the demo server, you gave it the URI http://localhost:8000/. This URI has a port number of 8000. But most of the web addresses you see in the wild don't have a port number on them. This is because the client usually figures out the port number from the URI scheme.</p>
                 
                 <p>For instance, HTTP URIs imply a port number of 80, whereas HTTPS URIs imply a port number of 443. Your Python demo web server is running on port 8000. Since this isn't the default port, you have to write the port number in URIs for it.</p>
                 
                 <p> <strong class="theCode">What's a port number, anyway?</strong> To get into that, we need to talk about how the Internet works. All of the network traffic that computers send and receive — everything from web requests, to login sessions, to file sharing — is split up into messages called <strong class="theCode">packets.</strong> Each packet has the IP addresses of the computer that sent it, and the computer that receives it. And (with the exception of some low-level packets, such as ping) it also has the <strong class="theCode">port number</strong> for the sender and recipient. IP addresses distinguish computers; port numbers distinguish programs on those computers.</p>
                 
                 <p>We say that a server "listens on" a port, such as 80 or 8000. "Listening" means that when the server starts up, it tells its operating system that it wants to receive connections from clients on a particular port number. When a client (such as a web browser) "connects to" that port and sends a request, the operating system knows to forward that request to the server that's listening on that port.</p>
                 
                 <blockquote class="blockquote">Why do we use port 8000 instead of 80 for the demo server? For historical reasons, operating systems only allow the administrator (or root) account to listen on ports below 1024. This is fine for production web servers, but it's not convenient for learning.</blockquote>
                 
                 <p class="theCode">The URI in the question is an HTTPS URI. The default port for HTTPS is port 443.</p>
                 
			</div>
		</div>
    
     <div class="card text-white bg-dark mb-3" style="max-width: 30rem;">
		  <div class=" ">
		  	<div class="card-header">HTTP GET Request
			  	<i class="fa fa-circle theIcon01" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon02" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon03" style="font-size:20px"></i>
		  	  </div>
		     </div>
		 	 <div class="card-body">
             <p>There are a lot of different types of HTTP requests. Every HTTP Request contains a VERB or Method which tels the server what kind of request the client is requesting  </p>
                 
            <h2>GET </h2>
                
            <p>What browser use when they ask a server to send them a copy of a resource.</p>
                 
		     <p class="card-text">Take a look back at the server logs on your terminal, where the demo server is running. When you request a page from the demo server, an entry appears in the logs with a message like this:</p>
                 
                 <p class="theCode">127.0.0.1 - - [03/Oct/2016 15:45:50] "GET /readme.png HTTP/1.1" 200 -</p>
                
                 <p>Take a look at the part right after the date and time. Here, it says "GET /readme.png HTTP/1.1". This is the text of the request line that the browser sent to the server. This log entry is the server telling you that it received a request that said, literally, GET /readme.png HTTP/1.1.</p>
                 
                 <p>TThis request has three parts.</p>
                 
                 <ul>
                     <li>The word GET is the method or HTTP verb being used; this says what kind of request is being made. GET is the verb that clients use when they want a server to send a resource, such as a web page or image. Later, we'll see other verbs that are used when a client wants to do other things, such as submit a form or make changes to a resource. </li>
                     
                     <li>/readme.png is the path of the resource being requested. Notice that the client does not send the whole URI of the resource here. It doesn't say https://localhost:8000/readme.png. It just sends the path. </li>
                     
                     <li>/Finally, HTTP/1.1 is the protocol of the request. Over the years, there have been several changes to the way HTTP works. Clients have to tell servers which dialect of HTTP they're speaking. HTTP/1.1 is the most common version today. </li>
                 </ul>
                 
                 
                 <hr>
                 
                 <h2>Exercise: Send a request manually</h2>
                 
                 <p>You can use ncat to connect to the demo server and send it an HTTP request by hand. (Make sure the demo server is still running!)</p>
                 
                 <p>Use <strong class="theCode"> $python3 -m http.server 8000  </strong> in your terminal to run the demo server.</p>
                 <p>Use <strong class="theCode"> $ncat 127.0.0.1 8000 </strong> (in a second ternimal)to connect your terminal to the demo server.</p>
                 
                 <p> Type the following and dopple press Enter afterwards</p>
                 <p>GET / HTTP/1.1</p>
                 <p>Host: localhost</p>
                 
                 <hr>
                 <h2>Results of the Request</h2>
                 <ul>
                    <li>HTTP/1.0 200 OK</li>
                    <li>Server: SimpleHTTP/0.6 Python/3.7.5 </li>
                    <li>Date: Sun, 05 Jan 2020 00:21:50 GMT</li>
                    <li>Content-type: text/html</li>
                    <li>Content-Length: 127</li>
                    <li>Last-Modified: Sat, 04 Jan 2020 21:46:26 GMT</li>
                    <li>and an HTML code</li>
                 </ul>
                 
                 
                 
			</div>
		</div>
    
    <div class="card text-white bg-dark mb-3" style="max-width: 30rem;">
		  <div class=" ">
		  	<div class="card-header">HTTP Response
			  	<i class="fa fa-circle theIcon01" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon02" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon03" style="font-size:20px"></i>
		  	  </div>
		     </div>
		 	 <div class="card-body">
             <p>After you typed Host: localhost and pressed Enter twice, the server sent back a lot of text. This is an HTTP response. One of these exchanges — a request and response — is happening every time your browser asks a server for a page, an image, or anything else. </p>
                 
            <p>Here's another one to try. Use ncat to connect to google.com port 80, and send a request for the path / on the host google.com:</p>
                 
                 <p>GEGT / HTTP/1.1</p>
                 <p>Host: google.com</p>

                 
                 
            <h2>HTTP RESPONSE </h2>
                
            <p>The HTTP response is made up of three parts: </p>
                 <ul>
                     <li> the status line</li>
                     <li> some headers</li>
                     <li> a response body</li>
                 </ul>
                 
		     <p class="card-text">The status line is the first line of text that the server sends back. The headers are the other lines up until the first blank line. The response body is the rest — in this case, it's a piece of HTML.</p>

                 
                 
			</div>
		</div>
    
    
    
        <div class="card text-white bg-dark mb-3" style="max-width: 30rem;">
		  <div class=" ">
		  	<div class="card-header">STATUS LINE
			  	<i class="fa fa-circle theIcon01" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon02" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon03" style="font-size:20px"></i>
		  	  </div>
		     </div>
		 	 <div class="card-body">
             <p>In the response you got from your demo server, the status line said <strong class="theCode">HTTP/1.0 200 OK</strong>. In the one from Google, it says <strong class="theCode">HTTP/1.1 301 Moved Permanently </strong>. The status line tells the client whether the server understood the request, whether the server has the resource the client asked for, and how to proceed next. It also tells the client which dialect of HTTP the server is speaking.</p>
                 
            <p>The numbers 200 and 301 here are HTTP status codes. There are dozens of different status codes. The first digit of the status code indicates the general success of the request. As a shorthand, web developers describe all of the codes starting with 2 as "2xx" codes, for instance — the x's mean "any digit".</p>
                 
                
            <p>The STATUS CODES: </p>
                 <ul>
                     <li> <strong class="theCode">1xx — Informational.</strong> The request is in progress or there's another step to take.</li> 
                     <li> <strong class="theCode">2xx — Success! </strong> The request succeeded. The server is sending the data the client asked for.</li>
                     <li> <strong class="theCode">3xx — Redirection. </strong> The server is telling the client a different URI it should redirect to. The headers will usually contain a Location header with the updated URI. Different codes tell the client whether a redirect is permanent or temporary.</li>
                     <li> <strong class="theCode">4xx — Client error. </strong> The server didn't understand the client's request, or can't or won't fill it. Different codes tell the client whether it was a bad URI, a permissions problem, or another sort of error.</li>
                     <li> <strong class="theCode">5xx — Server error. </strong> Something went wrong on the server side.</li>
                     
                 </ul>
                 
		     <p class="card-text">The server response here is an example of good user interface on the Web. Google wants browsers to use www.google.com instead of google.com. But instead of showing the user an error message, they send a redirect. Browsers will automatically follow the redirect and end up on the right site.</p>

                 
                 
			</div>
		</div>
    
    
        <div class="card text-white bg-dark mb-3" style="max-width: 30rem;">
		  <div class=" ">
		  	<div class="card-header">HEADERS and BODY RESPONSE
			  	<i class="fa fa-circle theIcon01" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon02" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon03" style="font-size:20px"></i>
		  	  </div>
		     </div>
		 	 <div class="card-body">
             <p>IAn HTTP response can include many headers. Each header is a line that starts with a keyword, such as Location or Content-type, followed by a colon and a value. Headers are a sort of metadata for the response. They aren't displayed by browsers or other clients; instead, they tell the client various information about the response.</p>
                 
            <p>Many, many features of the Web are implemented using headers. For instance, cookies are a Web feature that lets servers store data on the browser, for instance to keep a user logged in. To set a cookie, the server sends the Set-Cookie header. The browser will then send the cookie data back in a Cookie header on subsequent requests. You'll see more about cookies later in this course.</p>
                 
            <p class="theCode">Content-type: text/html; charset=utf-8</p>
                 
                
            <h2>Content-type</h2>
                 
		     <p class="card-text">A Content-type header indicates the kind of data that the server is sending. It includes a general category of content as well as the specific format. For instance, a PNG image file will come with the Content-type image/png. If the content is text (including HTML), the server will also tell what encoding it's written in. UTF-8 is a very common choice here, and it's the default for Python text anyway.</p>

            <p> Very often, the headers will contain more metadata about the response body. For instance, both the demo server and Google also send a Content-Length header, which tells the client how long (in bytes) the response body will be. If the server sends this, then the client can reuse the connection to send another request after it's read the first response. Browsers use this so they can fetch multiple pieces of data (such as images on a web page) without having to reconnect to the server.</p>
                 
            <h2>Body Response</h2>
                 
		     <p class="card-text">The headers end with a blank line. Everything after that blank line is part of the response body. If the request was successful (a 200 OK status, for instance), this is a copy of whatever resource the client asked for — such as a web page, image, or other pieces of data.</p>

            <p> But in the case of an error, the response body is where the error message goes! If you request a page that doesn't exist, and you get a 404 Not Found error, the actual error message shows up in the response body.</p>
                 
                 
			</div>
		</div>
    
    
    
</div>

</body>
</html>