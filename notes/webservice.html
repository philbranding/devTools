<!DOCTYPE html>
<html>
    <head>
	<title>WebServices</title>
	<link rel="stylesheet" type="text/css" href="external/css/bootstrap.css">
	<script type="text/javascript" src="./external/js/bootstrap.js" rel="javascript"></script>
    <script type="text/javascript" src="external/js/jquery.min.js" rel="javascript"></script>
  
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.16.0/umd/popper.min.js"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js"></script>

	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
	<link href="https://fonts.googleapis.com/css?family=Courier+Prime&display=swap" rel="stylesheet">
	<link rel="stylesheet" type="text/css" href="css/main.css">
	<meta charset="utf-8">
    <!--meta http-equiv="refresh" content="3.9"-->
</head>
<body>


 <nav class="navbar navbar-expand-lg navbar-dark bg-dark">
  <a class="navbar-brand" href="#">Phil Full-Stack Notes</a>
  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarTogglerDemo02" aria-controls="navbarTogglerDemo02" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

  <div class="collapse navbar-collapse" id="navbarTogglerDemo02">
    <ul class="navbar-nav mr-auto mt-2 mt-lg-0">
        
      <li class="nav-item active">
        <a class="nav-link" href="index.html">Home <span class="sr-only">(current)</span></a>
      </li>
        
      <li class="nav-item">
        <a class="nav-link" href="terminal.html">Terminal</a>
      </li>
        
        <li class="nav-item">
        <a class="nav-link" href="git.html">Git VCS</a>
      </li>
        
         <li class="nav-item">
        <a class="nav-link" href="database.html">Database</a>
      </li>
        
        <!-- Dropdown -->
    <li class="nav-item dropdown">
      <a class="nav-link dropdown-toggle" href="#" id="navbardrop" data-toggle="dropdown">
        Tools
      </a>
      <div class="dropdown-menu">
        <a class="dropdown-item" href="sql.html">SQL </a>
        <a class="dropdown-item" href="#">Boostrap 4</a>
        <a class="dropdown-item" href="#">Javascript</a>
        <a class="dropdown-item" href="httpprotocol.html">HTTP Protocol</a>
        <a class="dropdown-item" href="httpserver.html">HTTP Server</a>
        <a class="dropdown-item" href="webservice.html">WebServices</a>
      </div>
    </li>
        
         <li class="nav-item">
        <a class="nav-link" href="github.html">Git Hub</a>
      </li>
        
    </ul>
      
    <form class="form-inline my-2 my-lg-0">
      <input class="form-control mr-sm-2" type="search" placeholder="Search">
      <button class="btn btn-outline-success my-2 my-sm-0" type="submit">Search</button>
    </form>
  </div>
</nav>
    
<div class="jumbotron">
<div>
	<h1>Deploying to a Hosting Service</h1>
	<h3 class="notes">Can I just host my web service at home? </h3>
    <p> Maybe! Plenty of people do, but not everyone can. It's a common hobbyist activity, but not something that people would usually do for a job.</p>
    
    <p> There's nothing fundamentally special about the computers that run web servers. They're just computers running an operating system such as Linux, Mac OS, or Windows (usually Linux). Their connection to the Internet is a little different from a typical home or mobile Internet connection, though. A server usually needs to have a stable (static) IP address so that clients can find it and connect to it. Most home and mobile systems don't assign your computer a static IP address.</p>
    
    <p> Also, most home Internet routers don't allow incoming connections by default. You would need to reconfigure your router to allow it. This is totally possible, but way beyond the scope of this course (and I don't know what kind of router you have).</p>
    
    <p> Lastly, if you run a web service at home, your computer has to be always on.</p>
    
    <p> So, for the next exercise in this course, you'll be deploying one of your existing web services to <a href="https://www.heroku.com/" target="_blank" class="theCode">Heroku </a>, a commercial service that will host it on the web where it will be publicly accessible. </p>
    
        <div>
    <hr>
    
    </div>
    <div class="card text-white bg-dark mb-3">
       
        <h3 class="card-header"> Steps to Heroku deployment</h3>
        <ol>
            <li> Check your server code into a new local Git repository.</li>
            <li> Sign up for a free Heroku account.</li>
            <li> Download the Heroku <a href="https://devcenter.heroku.com/articles/heroku-cli"> command-line interface</a> (CLI).</li>
            <li>Authenticate the Heroku CLI with your account: <strong class="theCode"> heroku login</strong></li>
            <li>Create configuration files <strong class="theCode">Procfile </strong>, <strong class="theCode">requirements.txt</strong>, and <strong class="theCode">runtime.txt</strong> and check them into your Git repository.</li>
            <li>Modify your server to listen on a configurable port.</li>
            <li>Create your Heroku app: <strong class="theCode">heroku create your-app-name</strong> </li>
            <li>Push your code to Heroku with Git: <strong class="theCode">git push heroku master</strong> </li>
        </ol>
        
    </div>
    
    <div>
    <hr>
    
    </div>
    
    
	</div>
		
    	<div class="card text-white bg-info mb-3" style="max-width: 30rem;">
		  <div class=" ">
		  	<div class="card-header">>_. Check in your code
			  	<i class="fa fa-circle theIcon01" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon02" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon03" style="font-size:20px"></i>
		  	  </div>
		     </div>
		 	 <div class="card-body">
                 <h2> Check in your code </h2>
		     <p> Heroku (and many other web hosting services) works closely with Git: you can deploy a particular version of your code to Heroku by pushing it with the <strong class="theCode"> git push </strong> command. So in order to deploy your code, it first needs to be checked into a local Git repository.</p>
             
                 <blockquote class="blockquote">This Git repository should be separate from the one created when you downloaded the exercise code (the course-ud303 directory). Create a new directory outside of that directory and copy the bookmark server code (the file BookmarkServer.py from last lesson) into it. Then set this new directory up as a Git repository:</blockquote>
                 
                 <hr>
                                  
                 <ul>
                 <li class="theCode"> git init </li>
                 <li class="theCode"> git add BookmarkServer.py </li>
                 <li class="theCode"> git commit -m "Checking in my Bookmark server!" </li>                 
                 
                 </ul>
                 

                 <p>First, visit this link and follow the instructions to sign up for a free Heroku account:</p>
             
            <div class="theButton">  <button type="button" class="btn-lg btn-danger active "aria-pressed="true"><a href="https://signup.heroku.com/dc" class="theButton" target="_blank">SIGNUP </a></button> </div>
                 
                
		</div>
	</div>
    
    
    
    
    
		<div class="card text-white bg-dark mb-3" style="max-width: 30rem;">
		  <div class=" ">
		  	<div class="card-header">Create configuration files
			  	<i class="fa fa-circle theIcon01" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon02" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon03" style="font-size:20px"></i>
		  	  </div>
		     </div>
		 	 <div class="card-body">
		     <h5 class="card-title theCode">Create configuration files</h5>
		     <p class="card-text"> There are a few configuration files that Heroku requires for deployment, to tell its servers how to run your application. For the case of the bookmark server, I'll just give you the required content for these files. These are just plain text files and can be created in your favorite text editor. </p>
                 
            <p> <strong class="theCode"> runtime.txt </strong> tells Heroku what version of Python you want to run. <a href="https://devcenter.heroku.com/articles/python-runtimes" target="_blank">Check the currently supported runtimes in the Heroku documentation; this will change over time!</a> As of early 2020, the currently supported version of Python 3 is python-3.7.2; so this file just needs to contain the text python-3.7.2. </p>
                 
            <p><strong class="theCode">requirements.txt</strong> is used by Heroku (through <strong class="theCode">pip</strong>) to install dependencies of your application that aren't in the Python standard library. The bookmark server has one of these: the <strong class="theCode">requests</strong> module. We'd like a recent version of that, so this file can contain the text <strong class="theCode">requests>=2.12</strong>. This will install version 2.12 or a later version, if one has been released.</p>
                 
            <p><strong class="theCode">Procfile</strong> is used by Heroku to specify the command line for running your application. It can support running multiple servers, but in this case we're only going to run a web server. Check the Heroku documentation about process types for more details. If your bookmark server is in <strong class="theCode">BookmarkServer.py</strong>, then the contents of Procfile should be <strong class="theCode">web: python BookmarkServer.py</strong>.</p>
                 
            <hr>
                 
            <h3>Listen on a configurable port</h3>

            <p>There's one small change that you have to make to your server code to make it run on Heroku. The bookmark server from Lesson 2 listens on port 8000. But Heroku runs many users' processes on the same computer, and multiple processes can't (normally) listen on the same port. So Heroku needs to be able to tell your server what port to listen on.</p>
        
            <p>The way it does this is through an <strong class="theCode">environment variable</strong> — a configuration variable that is passed to your server from the program that starts it, usually the shell. Python code can access environment variables in the <strong class="theCode">os.environ</strong> dictionary. The names of environment variables are usually capitalized; and the environment variable we need here is called, unsurprisingly, <strong class="theCode">PORT</strong>.</p>
                 
            <p>The port your server listens on is configured when it creates the <strong class="theCode">HTTPServer</strong> instance, near the bottom of the server code. We can make it work with or without the <strong class="theCode">PORT</strong> environment variable, like so:</p>
                 
                 <ul>
                    <li class="theCode">if __name__ == '__main__':</li>
                        <ul>
                            <li class="theCode">port = int(os.environ.get('PORT', 8000))</li>
                            <li class="theCode">server_address = ('', port)</li>
                            <li class="theCode">httpd = http.server.HTTPServer(server_address, Shortener)</li>
                            <li class="theCode"> httpd.serve_forever()</li>
                        </ul>
                 
                 </ul>
            
            <p> To access <strong class="theCode">os.environ </strong>, you will also need to <strong class="theCode"> import os </strong>at the top of the file. </p>
                 
            <p>Make these changes to your server code, run the server locally to test that it still works, then commit it to your Git repository:</p>

                  
             <ul>
                <li class="theCode">git add BookmarkServer.py</li>
                <li class="theCode">git commit -m "Use PORT from environment."</li>
            </ul>
            
             <hr>
                 
            <h3>Create and push your app</h3>

            <p>Before you can put your service on the web, you have to give it a name. You can call it whatever you want, as long as the name is not already taken by another user! Your app's name will appear in the URI of your deployed service. For instance, if you name your app silly-pony, it will appear on the web at https://silly-pony.herokuapp.com/.</p>
        
            <p> Use <strong class="theCode">heroku create your-app-name</strong> to tell Heroku about your app and give it a name. Again, you can choose any name you like, but it will have to be unique — the service will tell you if you're choosing a name that someone else has already claimed.</p>
                 
            <p>Finally, use <strong class="theCode"> git push heroku master </strong> to deploy the app!</p>
                 
		</div>
	</div>



	<div class="card text-white bg-dark mb-3" style="max-width: 30rem;">
		  <div class=" ">
		  	<div class="card-header">Accessing server logs
			  	<i class="fa fa-circle theIcon01" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon02" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon03" style="font-size:20px"></i>
		  	  </div>
		     </div>
		 	 <div class="card-body">
		     <h5 class="card-title theCode">$python3 -m http.server 8000</h5>
                 <p class="card-text">If your app doesn't work quite right as deployed, one resource that can be very helpful is the server log. Since your service isn't running on your own local machine any more, those logs aren't going to show up in your terminal! Instead, they're available from the Heroku dashboard.</p>

                 <p>Take a look at https://dashboard.heroku.com/apps/little-bookmarks/logs, but replace "little-bookmarks" with your own app's name. </p>
		</div>
	</div>

	<div class="card text-white bg-dark mb-3" style="max-width: 30rem;">
		  <div class=" ">
		  	<div class="card-header">Concurrency
			  	<i class="fa fa-circle theIcon01" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon02" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon03" style="font-size:20px"></i>
		  	  </div>
		     </div>
		 	 <div class="card-body">
                 <p class="card-text ">Being able to handle two ongoing tasks at the same time is called concurrency, and the basic http.server.HTTPServer doesn't have it. It's pretty straightforward to plug concurrency support into an HTTPServer, though. The Python standard library supports doing this by adding a mixin to the HTTPServer class. A mixin is a sort of helper class, one that adds extra behavior the original class did not have. To do this, you'll need to add this code to your bookmark server:</p>
                 
                <ul>
                    <li class="theCode">import threading</li>
                    <li class="theCode">from socketserver import ThreadingMixIn</li>
                    <li class="theCode">class ThreadHTTPServer(ThreadingMixIn, http.server.HTTPServer):</li>
                    <li class="theCode">"This is an HTTPServer that supports thread-based concurrency."</li>
                </ul>
                 
                 <p>Then look at the bottom of your bookmark server code, where it creates an HTTPServer. Have it create a ThreadHTTPServer instead:</p>
                 
                  <ul>
                    <li class="theCode">if __name__ == '__main__':</li>
                        <ul>
                            <li class="theCode">port = int(os.environ.get('PORT', 8000))</li>
                            <li class="theCode">server_address = ('', port)</li>
                            <li class="theCode">httpd = ThreadHTTPServer(server_address, Shortener)</li>
                            <li class="theCode"> httpd.serve_forever()</li>
                        </ul>
                 
                 </ul>
                 
                 <p>Commit this change to your Git repository, and push it to Heroku. Now when you test it out, you should be able to add an entry that points to the service itself.</p>
		</div>
	</div>
		
		<div class="card text-white bg-dark mb-3" style="max-width: 30rem;">
		  <div class=" ">
		  	<div class="card-header">  What's an Apache or Nginx?
			  	<i class="fa fa-circle theIcon01" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon02" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon03" style="font-size:20px"></i>
		  	  </div>
		     </div>
		 	 <div class="card-body">
                 
                 <h2 class="card-title">What's an Apache or Nginx?</h2>
                 
                 <h3>Static content and more</h3>
                 
                 <p>The Web was originally designed to serve documents, not to deliver applications. Even today, a large amount of the data presented on any web site is static content — images, HTML files, videos, downloadable files, and other media stored on disk.</p>

                 <p>Specialized web server programs — like <a class="theCode" href="https://httpd.apache.org/" target="_blank">Apache</a>, <a href="https://www.nginx.com/resources/wiki/" target="_blank" class="theCode">Nginx</a>, or <a href="https://www.iis.net/" target="_blank" class="theCode">IIS</a> — can serve static content from disk storage very quickly and efficiently. They can also provide access control, allowing only authenticated users to download particular static content.</p>
                 
                 <h3>Routing and load balancing </h3>
                 
                 <p>Some web applications have several different server components, each running as a separate process. One thing a specialized web server can do is dispatch requests to the particular backend servers that need to handle each request. There are a lot of names for this, including request routing and reverse proxying.</p>
                 
                 <p>Some web applications need to do a lot of work on the server side for each request, and need many servers to handle the load. Splitting requests up among several servers is called load balancing.</p>
                 
                 <p> Load balancing also helps handle conditions where one server becomes unavailable, allowing other servers to pick up the slack. A reverse proxy can health check the backend servers, only sending requests to the ones that are currently up and running. This also makes it possible to do updates to the backend servers without having an outage.</p>  
                 
                 <h3>Concurrent users</h3>
                 
                 <p>Handling a large number of network connections at once turns out to be complicated — even more so than plugging concurrency support into your Python web service.</p>
                 
                 <p>As you may have noticed in your own use of the web, it takes time for a server to respond to a request. The server has to receive and parse the request, come up with the data that it needs to respond, and transmit the response back to the client. The network itself is not instantaneous; it takes time for data to travel from the client to the server.</p>
                 
                 <p>In addition, a browser is totally allowed to open up multiple connections to the same server, for instance to request resources such as images, or to perform API queries.</p>
                 
                 <p> All of this means that if a server is handling many requests per second, there will be many requests in progress at once — literally, at any instant in time. We sometimes refer to these as in-flight requests, meaning that the request has "taken off" from the client, but the response has not "landed" again back at the client. A web service can't just handle one request at a time and then go on to the next one; it has to be able to handle many at once.</p>
                 
                 <h3>Caching</h3>
                 
                 <p>Imagine a web service that does a lot of complicated processing for each request — something like calculating the best route for a trip between two cities on a map. Pretty often, users make the same request repeatedly: imagine if you load up that map, and then you reload the page — or if someone else loads the same map. It's useful if the service can avoid recalculating something it just figured out a second ago. It's also useful if the service can avoid re-sending a large object (such as an image) if it doesn't have to.</p>
                 
                 <p>One way that web services avoid this is by making use of a cache, a temporary storage for resources that are likely to be reused. Web systems can perform caching in a number of places — but all of them are under control of the server that serves up a particular resource. That server can set HTTP headers indicating that a particular resource is not intended to change quickly, and can safely be cached.</p>
                 
                 <p>There are a few places that caching usually can happen. Every user's browser maintains a browser cache of cacheable resources — such as images from recently-viewed web pages. The browser can also be configured to pass requests through a web proxy, which can perform caching on behalf of many users. Finally, a web site can use a reverse proxy to cache results so they don't need to be recomputed by a slower application server or database.</p>
                 
                 <p> All HTTP caching is supposed to be governed by cache control headers set by the server. You can read a lot more about them in this article by Google engineer Ilya Grigorik.</p>
                 
                 <h3>Capacity</h3>
                 
                 <p>hy serve static requests out of cache (or a static web server) rather than out of your application server? Python code is totally capable of sending images or video via HTTP, after all. The reason is that — all else being equal — handling a request faster provides a better user experience, but also makes it possible for your service to support more requests.</p>
                 
                 <p>If your web service becomes popular, you don't want it to bog down under the strain of more traffic. So it helps to handle different kinds of request with software that can perform that function quickly and efficiently.</p>
                 
                 <p> All HTTP caching is supposed to be governed by cache control headers set by the server. You can read a lot more about them in this article by Google engineer Ilya Grigorik.</p>

			</div>
		</div>
		
		<div class="card text-white bg-dark mb-3" style="max-width: 30rem;">
		  <div class=" ">
		  	<div class="card-header">Cookies
			  	<i class="fa fa-circle theIcon01" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon02" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon03" style="font-size:20px"></i>
		  	  </div>
		     </div>
		 	 <div class="card-body">
		     <h3 class="card-title">Cookies </h3>

		          <p class="card-text">Cookies are a way that a server can ask a browser to retain a piece of information, and send it back to the server when the browser makes subsequent requests. Every cookie has a name and a value, much like a variable in your code; it also has rules that specify when the cookie should be sent back.</p>

                 <p> What are cookies for? A few different things. If the server sends each client a unique cookie value, it can use these to tell clients apart. This can be used to implement higher-level concepts on top of HTTP requests and responses — things like sessions and login. Cookies are used by analytics and advertising systems to track user activity from site to site. Cookies are also sometimes used to store user preferences for a site.</p>
                 
                 
                 <h3>How cookies happen</h3>
                 
                 <p>The first time the client makes a request to the server, the server sends back the response with a Set-Cookie header. This header contains three things: a cookie name, a value, and some attributes. Every subsequent time the browser makes a request to the server, it will send that cookie back to the server. The server can update cookies, or ask the browser to expire them.</p>
                 
                 <h3>Seeing cookies in your browser</h3>
                 
                 <p>Browsers don't make it easy to find cookies that have been set, because removing or altering cookies can affect the expected behavior of web services you use. However, it is possible to inspect cookies from sites you use in every major browser. Do some research on your own to find out how to view the cookies that your browser is storing.</p>
                 

                 <blockquote class="blockquote">
                 By the way, if you try to research "cookie fields" with a web search, you may get a lot of results from the Mrs. Fields cookie company. Try "HTTP cookie fields" for more relevant results.
                 </blockquote>
                 
                 <p>The first two, the cookie's name and content, are also called its key and value. They're analogous to a dictionary key and value in Python — or a variable's name and value for that matter. They will both be sent back to the server. There are some syntactic rules for which characters are allowed in a cookie name; for instance, they can't have spaces in them. The value of the cookie is where the "real data" of the cookie goes — for instance, a unique token representing a logged-in user's session.</p>
                 
                 <p>The next two fields, Domain and Path, describe the scope of the cookie — that is to say, which queries will include it. By default, the domain of a cookie is the hostname from the URI of the response that set the cookie. But a server can also set a cookie on a broader domain, within limits. For instance, a response from <strong class="theCode">www.udacity.com</strong> can set a cookie for <strong class="theCode">udacity.com</strong>, but not for <strong class="theCode">com</strong>.</p>
                 
                 <p>The fields that Chrome describes as "Send for" and "Accessible to script" are internally called Secure and HttpOnly, and they are boolean flags (true or false values). The internal names are a little bit misleading. If the Secure flag is set, then the cookie will only be sent over HTTPS (encrypted) connections, not plain HTTP. If the HttpOnly flag is set, then the cookie will not be accessible to JavaScript code running on the page.</p>
                 
                 <p>Finally, the last two fields deal with the lifetime of the cookie — how long it should last. The creation time is just the time of the response that set the cookie. The expiration time is when the server wants the browser to stop saving the cookie. There are two different ways a server can set this: it can set an Expires field with a specific date and time, or a Max-Age field with a number of seconds. If no expiration field is set, then a cookie is expired when the browser closes.</p>
                 
                 <h3> Using cookies in Python </h3>
                 
                 <p>To set a cookie from a Python HTTP server, all you need to do is set the <strong class="theCode"> Set-Cookie</strong> header on an HTTP response. Similarly, to read a cookie in an incoming request, you read the <strong class="theCode">Cookie</strong> header. However, the format of these headers is a little bit tricky; I don't recommend formatting them by hand. Python's <strong class="theCode">http.cookies</strong> module provides handy utilities for doing so. </p>
                 
                 <p>To create a cookie on a Python server, use the <strong class="theCode">SimpleCookie</strong> class. This class is based on a dictionary, but has some special behavior once you create a key within it:</p>
                 
                 <ul>
                     <li class="theCode"> from http.cookies import SimpleCookie, CookieError </li>
                     <p></p>
                     <li class="theCode"> out_cookie = SimpleCookie()</li>
                     <li class="theCode">out_cookie["bearname"] = "Smokey Bear"</li>
                     <li class="theCode">out_cookie["bearname"]["max-age"] = 600</li>
                     <li class="theCode">out_cookie["bearname"]["httponly"] = True</li>
                 </ul>
                 
                 
                 <p>Then you can send the cookie as a header from your request handler:</p>
                 
                 <p class="theCode">self.send_header("Set-Cookie", out_cookie["bearname"].OutputString())</p>
                 
                 <p>To read incoming cookies, create a <strong class="theCode">SimpleCookie</strong> from the <strong class="theCode">Cookie</strong> header:</p>
                 
                  <p> As a result, you are getting a dictionary with the values passed in the Url:</p>
                 
                   <ul>
                     <li class="theCode"> in_cookie = SimpleCookie(self.headers["Cookie"]) </li>
                     <li class="theCode"> in_data = in_cookie["bearname"].value </li>
                 </ul>
                 
                 <p>Be aware that a request might not have a cookie on it, in which case accessing the <strong class="theCode">Cookie</strong> header will raise a <strong class="theCode">KeyError</strong> exception; or the cookie might not be valid, in which case the <strong class="theCode">SimpleCookie</strong> constructor will raise <strong class="theCode">http.cookies.CookieError</strong>.</p>

                  <blockquote class="blockquote">Important safety tip: Even though browsers make it difficult for users to modify cookies, it's possible for a user to modify a cookie value. Higher-level web toolkits, such as Flask (in Python) or Rails (in Ruby) will cryptographically sign your cookies so that they won't be accepted if they are modified. Quite often, high-security web applications use a cookie just to store a session ID, which is a key to a server-side database containing user information.</blockquote>
                 
                 <blockquote class="blockquote">Another important safety tip: If you're displaying the cookie data as HTML, you need to be careful to escape any HTML special characters that might be in it. An easy way to do this in Python is to use the html.escape function, from the built-in html module!</blockquote>
                 
                 <p>A server that remembers you</p>
                 
                 <p>In this exercise, you'll build a server that asks for your name, and then stores your name in a cookie on your browser. You'll be able to see that cookie in your browser's cookie data. Then when you visit the server again, it'll already know your name.</p>
                 
                 <h3>DNS domains and cookie security</h3>
                 
                 <p>Back in Lesson 1, you used the host or nslookup command to look up the IP addresses of a few different web services, such as Wikipedia and your own localhost. But domain names play a few other roles in HTTP besides just being easier to remember than IP addresses. A DNS domain links a particular hostname to a computer's IP address. But it also indicates that the owner of that domain intends for that computer to be treated as part of that domain.</p>
                 
                 <p> Imagine what a bad guy could do if they could convince your browser that their server evilbox was part of (say) Facebook, and get you to request a Facebook URL from evilbox instead of from Facebook's real servers. Your browser would send your facebook.com cookies to evilbox along with that request. But these cookies are what prove your identity to Facebook … so then the bad guy could use those cookies to access your Facebook account and send spam messages to all your friends.</p>
                 
                 <p>In the immortal words of Dr. Egon Spengler: It would be bad.</p>
                 
                 <p>This is just one reason that DNS is essential to web security. If a bad guy can take control of your site's DNS domain, they can send all your web traffic to their evil server … and if the bad guy can fool users' browsers into sending that traffic their way, they can steal the users' cookies and reuse them to break into those users' accounts on your site.</p>
                 
                 
                 

		</div>
	</div>

	<div class="card text-white bg-dark mb-3" style="max-width: 30rem;">
		  <div class=" ">
		  	<div class="card-header"> HTTPS 
			  	<i class="fa fa-circle theIcon01" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon02" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon03" style="font-size:20px"></i>
		  	  </div>
		     </div>
		 	 <div class="card-body">
		     <h2>What HTTPS does for you </h2>
		     <p class="card-text">When a browser and a server speak HTTPS, they're just speaking HTTP, but over an encrypted connection. The encryption follows a standard protocol called Transport Layer Security, or TLS for short. TLS provides some important guarantees for web security:</p>
                 
                 <ul>
                     <li>It keeps the connection <strong class="theCode"> private </strong>by encrypting everything sent over it. Only the server and browser should be able to read what's being sent.</li>
                     <li>It lets the browser <strong class="theCode">authenticate</strong> the server. For instance, when a user accesses <strong class="theCode">https://www.udacity.com/</strong>, they can be sure that the response they're seeing is really from Udacity's servers and not from an impostor.</li>
                     <li>It helps protect the <strong class="theCode">integrity</strong> of the data sent over that connection — checking that it has not been (accidentally or deliberately) modified or replaced.</li>
                 </ul>
                 
                 <blockquote class="blockquote">Note: TLS is also very often referred to by the older name SSL (Secure Sockets Layer). Technically, SSL is an older version of the encryption protocol. This course will talk about TLS because that's the current standard.</blockquote>
                 
                 <h2> Examples of Attacks</h2>
                 
                 <p> <strong class="theCode"> Privacy : </strong>You're reading your email in a coffee shop, and the shop owner can read your email off of their Wi-Fi network you're using.</p>
                 
                 <p> <strong class="theCode"> Authenticity : </strong>You think you're logging into Facebook, but actually you're sending your Facebook password to a server in the coffee shop's back room.</p>
                 
                 <p> <strong class="theCode"> Integrity : </strong>The coffee shop owner doesn't like cat pictures, so they replace all the cat pictures on the web pages you're looking at with pictures of celery.</p>
                 
			</div>
		</div>

	<div class="card text-white bg-dark mb-3" style="max-width: 30rem;">
		  <div class=" ">
		  	<div class="card-header">Inspecting TLS on your service
			  	<i class="fa fa-circle theIcon01" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon02" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon03" style="font-size:20px"></i>
		  	  </div> 
		     </div>
		 	 <div class="card-body">
		     <h2>SSL and TLS </h2>
		     <p class="card-text">Note: In some browser documentation you'll see references to SSL certificates. These are the same as TLS certificates. Remember, SSL is just the older version of the encryption standard.</p>

                 <p> Most Browsers have a lock icon next to the URI when you're viewing an HTTPS web site.</p>
                 <p> Clicking on the lock is how you start exploring the details of the HTTPS connection.</p>
                 
                <h3>What does it mean?</h3>

                 
                 <blockquote class="blockquote">
                    <p>Those are how the browser indicates to the user that their connection is being protected by TLS. However, these dialogs also show a little about the server's TLS setup.</p>
                 </blockquote>
                 
                 
                <h3>Keys and Certificates</h3>
                 
                 
                 <p>The server-side configuration for TLS includes two important pieces of data: <strong class="theCode"> a private key </strong> and <strong class="theCode"> a public certificate </strong>. The private key is secret; it's held on the server and never leaves there. The certificate is sent to every browser that connects to that server via TLS. These two pieces of data are mathematically related to each other in a way that makes the encryption of TLS possible.</p>
                 
                 <p>The server's certificate is issued by an organization called a <strong class="theCode">certificate authority (CA) </strong>. The certificate authority's job is to make sure that the server really is who it says it is — for instance, that a certificate issued in the name of Heroku is actually being used by the Heroku organization and not by someone else.</p>
                 
                 <blockquote class="blockquote">The role of a certificate authority is kind of like getting a document notarized. A notary public checks your ID and witnesses you sign a document, and puts their stamp on it to indicate that they did so.</blockquote>
                 
                 
                  <h3>How does TLS assure privacy?</h3>
                 
                 <p>The data in the TLS certificate and the server's private key are mathematically related to each other through a system called <a href="https://en.wikipedia.org/wiki/Public-key_cryptography" target="_blank" class="theCode"> public-key cryptography</a>. The details of how this works are way beyond the scope of this course. The important part is that the two endpoints (the browser and server) can securely agree on a shared secret which allows them to scramble the data sent between them so that only the other endpoint — and not any eavesdropper — can unscramble it.</p>
                
                 <h3>How does TLS assure authentication?</h3>
                 
                 <p>A server certificate indicates that an encryption key belongs to a particular organization responsible for that service. It's the job of a certificate authority to make sure that they don't issue a cert for (say) udacity.com to someone other than the company who actually runs that domain.</p>
                 
                 <p>But the cert also contains metadata that says what DNS domain the certificate is good for. The cert in the picture above is only good for sites in the .herokuapp.com domain. When the browser connects to a particular server, if the TLS domain metadata doesn't match the DNS domain, the browser will reject the certificate and put up a big scary warning to tell the user that something fishy is going on </p>
                 
                 <h3>How does TLS assure integrity?</h3>
                 
                 <blockquote class="blockquote">Every request and response sent over a TLS connection is sent with a message authentication code (MAC) that the other end of the connection can verify to make sure that the message hasn't been altered or damaged in transit.</blockquote>
                 
                 <p>If your browser believes the attacker's server is udacity.com, it will send your udacity.com authentication cookies to the attacker's server. They can then put those cookies in their own web client and masquerade as you when talking to the real site. Also, if your browser is fetching content from the attacker's server, the attacker can put whatever they want in that content. They could even forward most of the content from the real server.</p>

                 <p>However, compromising Udacity's site would not allow an attacker to break into your Gmail or Facebook accounts, and fortunately it wouldn't let the attacker blow up your computer either.</p>
                 
                 <p>HTTPS only protects your data in transit. It doesn't protect it from an attacker who has taken over your computer, or the computer that's running your service.</p>

			</div>
		</div>
    
    <div class="card text-white bg-dark mb-3" style="max-width: 30rem;">
		  <div class=" ">
		  	<div class="card-header">All of the other methods

			  	<i class="fa fa-circle theIcon01" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon02" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon03" style="font-size:20px"></i>
		  	  </div>
		     </div>
		 	 <div class="card-body">
		     <h5 class="card-title theCode">API exposes the Server Side Parts </h5>
                 
                 <p class="card-text">APIs are a huge part of the morden web. A lot of web application makes use of a server side part that exposes an API and a client side that sends queries to that API, but not every API call makes sense as a GET or POST query </p>
                 
                 <p>The GET Method is really for requesting a copy of a resource and Post is for things that act more or less like form submission. </p>

                 <p>The different HTTP methods each stand for different actions that a client might need to perform upon a server-hosted resource. Unlike <strong class="theCode"> GET </strong> and <strong class="theCode">POST</strong>, their usage isn't built into the normal operation of web browsers; following a link is always going to be a GET request, and the default action for submitting an HTML form will always be a <strong class="theCode">GET</strong> or <strong class="theCode">POST</strong> request.</p>

                 <p>However, other methods are available for web APIs to use, for instance from client code in JavaScript. If you want to use other methods in your own full-stack applications, you'll have to write both server-side code to accept them, and client-side JavaScript code to make use of them.</p>
                 
                 
                 <h3>PUT for creating resources </h3>
                 
                 <p> The HTTP <strong class="theCode">PUT</strong> method can be used for creating a new resources. The client sends the URI path that it wants to create, and a piece of data in the request body. A server could implement <strong class="theCode">PUT</strong> in a number of different ways — such as storing a file on disk, or adding records to a database. A server should respond to a <strong class="theCode">PUT </strong>request with a <strong class="theCode">201 Created</strong> status code, if the PUT action completed successfully. After a successful <strong class="theCode">PUT</strong>, a <strong class="theCode">GET</strong> request to the same URI should return the newly created resource.</p>

                 <hr>
                 
                 <h3>DELETE for, well, deleting things</h3>
                 
                 <p>The destructive counterpart to <strong class="theCode">PUT</strong> is <strong class="theCode">DELETE</strong>, for removing a resource from the server. After a <strong class="theCode">DELETE</strong> has happened successfully, further <strong class="theCode">GET</strong> requests for that resource will yield <strong class="theCode">404 Not Found</strong> ... unless, of course, a new resource is later created with the same name!</p>

                 <p>But a handler class can have do_POST as well, to support GET and POST requests. This is exactly how the messageboard server will work.</p>

                 <p>When a GET request comes in, the server will send the HTML form and current messages. When a POST request comes in with a new message, the server will store the message in a list, and then return all the messages it's seen so far.</p>

                 <p>The code for a do_POST method will need to do some pretty different things from a do_GET method. When we're handling a GET request, all the user data in the request is in the URI path. But in a POST request, it's in the request body.</p>

                 <p>Inside do_POST, our code can read the request body by calling the self.rfile.read method. self.rfile is a file object, like the self.wfile we saw earlier — but rfile is for reading the request, rather than writing the response.</p>

                 <p>However, self.rfile.read needs to be told how many bytes to read … in other words, how long the request body is.</p>
                 
                <p>If there's a request body at all, the browser will send the length of the request body in the Content-Length header.</p>

			</div>
		</div>
    
    <div class="card text-white bg-dark mb-3" style="max-width: 30rem;">
		  <div class=" ">
		  	<div class="card-header">Headers are strings (or missing)
			  	<i class="fa fa-circle theIcon01" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon02" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon03" style="font-size:20px"></i>
		  	  </div>
		     </div>
		 	 <div class="card-body">
		     <h5 class="card-title theCode">Still under POST </h5>
		     <p class="card-text">The handler class gives us access to the HTTP headers as the instance variable self.headers, which is an object that acts a lot like a Python dictionary. The keys of this dictionary are the header names, but they're case-insensitive: it doesn't matter if you look up 'content-length' or 'Content-Length'. The values in this dictionary are strings: if the request body is 140 bytes long, the value of the Content-length entry will be the string "140". We need to call self.rfile.read(140) to read 140 bytes; so once we read the header, we'll need to convert it to an integer.</p>

                <p>But in an HTTP request, it's also possible that the body will be empty, in which case the browser might not send a Content-length header at all. This means we have to be a little careful when accessing the headers from the self.headers object. If we do self.headers['content-length'] and there's no such header, our code will crash with a KeyError. Instead, we'll use the .get dictionary method to get the header value safely.</p>

                 <p>So here's a little bit of code that can go in the do_POST handler to find the length of the request body and read it:
		      </p>
                 
                 <p class="theCode">length = int(self.headers.get('Content-length', 0))</p>
                <p class="theCode">data = self.rfile.read(length).decode()</p>
                 
                 <blockquote class="blockquote">
                 Once you read the message body, you can use urllib.parse.parse_qs to extract the POST parameters from it.
                 </blockquote>
                

			</div>
		</div>
    
    <div class="card text-white bg-dark mb-3" style="max-width: 30rem;">
		  <div class=" ">
		  	<div class="card-header">Post-Redirect-Get
			  	<i class="fa fa-circle theIcon01" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon02" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon03" style="font-size:20px"></i>
		  	  </div>
		     </div>
		 	 <div class="card-body">
		     <h5 class="card-title theCode"> &lt;a href="cliffsofinsanity.png"&gt;cliffsofinsanity.png&lt;/a&gt;</h5>
		     <p class="card-text">There's a very common design pattern for interactive HTTP applications and APIs, called the PRG or Post-Redirect-Get pattern. A client POSTs to a server to create or update a resource; on success, the server replies not with a 200 OK but with a 303 redirect. The redirect causes the client to GET the created or updated resource.</p>

             <p>This is just one of many, many ways to architect a web application, but it's one that makes good use of HTTP methods to accomplish specific goals. For instance, wiki sites such as Wikipedia often use Post-Redirect-Get when you edit a page.</p>
                 
            <p>For the messageboard server, Post-Redirect-Get means:</p>
            <ol>
                <li>You go to http://localhost:8000/ in your browser. Your browser sends a GET request to the server, which replies with a 200 OK and a piece of HTML. You see a form for posting comments, and a list of the existing comments. (But at the beginning, there are no comments posted yet.) </li>
                <li>You write a comment in the form and submit it. Your browser sends it via POST to the server.</li>
                <li>The server updates the list of comments, adding your comment to the list. Then it replies with a 303 redirect, setting the Location: / header to tell the browser to request the main page via GET.</li>
                <li>The redirect response causes your browser to go back to the same page you started with, sending a GET request, which replies with a 200 OK and a piece of HTML …</li>
                 
            </ol>
                <p>One big advantage of Post-Redirect-Get is that as a user, every page you actually see is the result of a GET request, which means you can bookmark it, reload it, and so forth — without ever accidentally resubmitting a form.</p>
                 
			</div>
		</div>
    
    
        <div class="card text-white bg-dark mb-3" style="max-width: 30rem;">
		  <div class=" ">
		  	<div class="card-header">Making requests
			  	<i class="fa fa-circle theIcon01" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon02" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon03" style="font-size:20px"></i>
		  	  </div>
		     </div>
		 	 <div class="card-body">
                <p class="theCode"> requests.get("http://localhost:8000/")</p>
                 
                 <p>The requests function for performing GET requests is requests.get, and it takes the URI as an argument.</p>
                 
                    <p>The requests library is a Python library for sending requests to web servers and interpreting the responses. It's not included in the Python standard library, though; you'll need to install it. In your terminal, run pip3 install requests to fetch and install the requests library.</p>
                 
		         <a href="https://2.python-requests.org//en/master/user/quickstart/" target="_blank"><button type="button" class="btn-lg btn-danger "s>Requests</button></a>
                <hr>
                
		     <p class="card-text">If you follow these links in your browser, it will fetch the same page from Wikipedia's web server. But the second one displays the page scrolled to the section about the discovery of oxygen. The part of the URI after the <strong class="theCode">#</strong> sign is called a <strong class="theCode">fragment</strong>. The browser doesn't even send it to the web server. It lets a link point to a specific named part of a resource; in HTML pages it links to an element by id.</p>
                 
                 <p>In contrast, consider this Google Search URI:</p>
                 
                 <ul>
                     <li class="theCode">>>> import requests
                     <li class="theCode">>>> a = requests.get("http://udacity.com")</li>
                     <li class="theCode">>>> a</li>
                     <li class="theCode">Response [200]</li>
                     <li class="theCode">>>> type(a)</li>
                     <li class="theCode"> class 'requests.models.Response'</li>            
                 </ul>
                 
                
                 <h3>r.content or r.text</h3>
                 <p>Both, but they're different. r.content is a bytes object representing the literal binary data that the server sent. r.text is the same data but interpreted as a str object, a Unicode string.</p>
                 
                 
                 <h3>Handling errors</h3>
                 
                 <p>If the requests.get call can reach an HTTP server at all, it will give you a Response object. If the request failed, the Response object has a status_code data member — either 200, or 404, or some other code.</p>

                 <p>But if it wasn't able to get to an HTTP server, for instance because the site doesn't exist, then requests.get should raise an exception.</p>

                 <p>However: Some Internet service providers will try to redirect browsers to an advertising site if you try to access a site that doesn't exist. This is called DNS hijacking, and it's nonstandard behavior, but some do it anyway. If your ISP hijacks DNS, you won't get exceptions when you try to access nonexistent sites. Standards-compliant DNS services such as Google Public DNS don't hijack.</p>
                 
			</div>
		</div>
    
    <div class="card text-white bg-dark mb-3" style="max-width: 30rem;">
		  <div class=" ">
		  	<div class="card-header">Using a JSON API
			  	<i class="fa fa-circle theIcon01" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon02" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon03" style="font-size:20px"></i>
		  	  </div>
		     </div>
		 	 <div class="card-body">
            <h5 class="card-title theCode">Using a JSON API </h5>
                 
                 <p>As a web developer, you will deal with data in a lot of different formats, especially when your code calls out to APIs provided by other developers. It's not uncommon for a large software system to have parts that deal with a dozen or more different data formats. Fortunately, usually, someone else has already written libraries to help you read and write these formats.</p>
                 
                 
		          <p class="card-text">JSON is a data format based on the syntax of JavaScript, often used for web-based APIs. There are a lot of services that let you send HTTP queries and get back structured data in JSON format. You can read more about the JSON format at http://www.json.org/.</p>

                 <p>Python has a built-in json module; and as it happens, the requests module makes use of it. A Response object has a .json method; if the response data is JSON, you can call this method to translate the JSON data into a Python dictionary.</p>

                 <p>Try it out! Here, I'm using it to access the Star Wars API, a classic JSON demonstration that contains information about characters and settings in the Star Wars movies:</p>
                 
                 <p class="theCode">>>> a = requests.get('http://swapi.co/api/people/1/')</p>
                 <p class="theCode">>>> a.json()['name']</p>
                 <p class="theCode">'Luke Skywalker'</p>
                 
                 <hr>
                 
                 <h2>Extract data from a JSON response</h2>
                 
                 <p>There's a great example of an API on the site http://uinames.com/, a service that makes up fake names and user account information. You can find the full API documentation under the little menu at the top right.</p>

                 <p>For this exercise, all you'll need is this URI and a couple of query parameters:</p>

                 <p class="theCode">http://uinames.com/api/</p>

                 <p>The query parameters to use are ext, which gives you a record with more fields, and region, which lets you specify which country you want your imaginary person to come from. For instance, to have the API invent a person from Italy:</p>

                 <p class="theCode">http://uinames.com/api?ext&region=Italy</p>

                 <p>(It's not perfect. For instance, currently it makes up North American phone numbers for everyone, regardless of where they live.)</p>
                 
                 <hr>
                 
			</div>
		</div>
    
     <div class="card text-white bg-dark mb-3" style="max-width: 30rem;">
		  <div class=" ">
		  	<div class="card-header">The bookmark server
			  	<i class="fa fa-circle theIcon01" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon02" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon03" style="font-size:20px"></i>
		  	  </div>
		     </div>
		 	 <div class="card-body">
                 <p>You're almost to the end of this lesson! One more server to write …</p>

                 <p>You've probably seen URL-shortening services such as TinyURL.</p>

                 <p>They let you create short URI paths like https://tinyurl.com/jye5r6l that redirect to a longer URI on another site. It's easier to put a short URI into an email, text message, or tweet. In this exercise, you'll be writing a service similar to this.</p>

                 <p>Like the messageboard server, this bookmark server will keep all of its data in memory. This means that it'll be reset if you restart it.</p>

                 <p>Your server needs to do three things, depending on what kind of request it receives: </p>
                 
                 <ul>
                     <li>On a GET request to the / path, it displays an HTML form with two fields. One field is where you put the long URI you want to shorten. The other is where you put the short name you want to use for it. Submitting this form sends a POST to the server.</li>
                     
                     <li>On a POST request, the server looks for the two form fields in the request body. If it has those, it first checks the URI with requests.get to make sure that it actually exists (returns a 200).</li>
                     
                     <ul>
                        <li>If the URI exists, the server stores a dictionary entry mapping the short name to the long URI, and returns an HTML page with a link to the short version. </li>
                        <li>If the URI doesn't actually exist, the server returns a 404 error page saying so. </li>
                        <li>If either of the two form fields is missing, the server returns a 400 error page saying so.</li>
                     </ul>
                     
                     <li>On a GET request to an existing short URI, it looks up the corresponding long URI and serves a redirect to it.</li>
                 </ul>
                 
                 
                 <hr>
                 
                 <h2>Exercise: Send a request manually</h2>
                 
                 <p>You can use ncat to connect to the demo server and send it an HTTP request by hand. (Make sure the demo server is still running!)</p>
                 
                 <p>Use <strong class="theCode"> $python3 -m http.server 8000  </strong> in your terminal to run the demo server.</p>
                 <p>Use <strong class="theCode"> $ncat 127.0.0.1 8000 </strong> (in a second ternimal)to connect your terminal to the demo server.</p>
                 
                 <p> Type the following and dopple press Enter afterwards</p>
                 <p>GET / HTTP/1.1</p>
                 <p>Host: localhost</p>
                 
                 <hr>
                 <h2>Results of the Request</h2>
                 <ul>
                    <li>HTTP/1.0 200 OK</li>
                    <li>Server: SimpleHTTP/0.6 Python/3.7.5 </li>
                    <li>Date: Sun, 05 Jan 2020 00:21:50 GMT</li>
                    <li>Content-type: text/html</li>
                    <li>Content-Length: 127</li>
                    <li>Last-Modified: Sat, 04 Jan 2020 21:46:26 GMT</li>
                    <li>and an HTML code</li>
                 </ul>
                 
                 
                 
			</div>
		</div>
    
    <div class="card text-white bg-dark mb-3" style="max-width: 30rem;">
		  <div class=" ">
		  	<div class="card-header">HTTP Response
			  	<i class="fa fa-circle theIcon01" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon02" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon03" style="font-size:20px"></i>
		  	  </div>
		     </div>
		 	 <div class="card-body">
             <p>After you typed Host: localhost and pressed Enter twice, the server sent back a lot of text. This is an HTTP response. One of these exchanges — a request and response — is happening every time your browser asks a server for a page, an image, or anything else. </p>
                 
            <p>Here's another one to try. Use ncat to connect to google.com port 80, and send a request for the path / on the host google.com:</p>
                 
                 <p>GEGT / HTTP/1.1</p>
                 <p>Host: google.com</p>

                 
                 
            <h2>HTTP RESPONSE </h2>
                
            <p>The HTTP response is made up of three parts: </p>
                 <ul>
                     <li> the status line</li>
                     <li> some headers</li>
                     <li> a response body</li>
                 </ul>
                 
		     <p class="card-text">The status line is the first line of text that the server sends back. The headers are the other lines up until the first blank line. The response body is the rest — in this case, it's a piece of HTML.</p>

                 
                 
			</div>
		</div>
    
    
    
        <div class="card text-white bg-dark mb-3" style="max-width: 30rem;">
		  <div class=" ">
		  	<div class="card-header">STATUS LINE
			  	<i class="fa fa-circle theIcon01" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon02" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon03" style="font-size:20px"></i>
		  	  </div>
		     </div>
		 	 <div class="card-body">
             <p>In the response you got from your demo server, the status line said <strong class="theCode">HTTP/1.0 200 OK</strong>. In the one from Google, it says <strong class="theCode">HTTP/1.1 301 Moved Permanently </strong>. The status line tells the client whether the server understood the request, whether the server has the resource the client asked for, and how to proceed next. It also tells the client which dialect of HTTP the server is speaking.</p>
                 
            <p>The numbers 200 and 301 here are HTTP status codes. There are dozens of different status codes. The first digit of the status code indicates the general success of the request. As a shorthand, web developers describe all of the codes starting with 2 as "2xx" codes, for instance — the x's mean "any digit".</p>
                 
                
            <p>The STATUS CODES: </p>
                 <ul>
                     <li> <strong class="theCode">1xx — Informational.</strong> The request is in progress or there's another step to take.</li> 
                     <li> <strong class="theCode">2xx — Success! </strong> The request succeeded. The server is sending the data the client asked for.</li>
                     <li> <strong class="theCode">3xx — Redirection. </strong> The server is telling the client a different URI it should redirect to. The headers will usually contain a Location header with the updated URI. Different codes tell the client whether a redirect is permanent or temporary.</li>
                     <li> <strong class="theCode">4xx — Client error. </strong> The server didn't understand the client's request, or can't or won't fill it. Different codes tell the client whether it was a bad URI, a permissions problem, or another sort of error.</li>
                     <li> <strong class="theCode">5xx — Server error. </strong> Something went wrong on the server side.</li>
                     
                 </ul>
                 
		     <p class="card-text">The server response here is an example of good user interface on the Web. Google wants browsers to use www.google.com instead of google.com. But instead of showing the user an error message, they send a redirect. Browsers will automatically follow the redirect and end up on the right site.</p>

                 
                 
			</div>
		</div>
    
    
        <div class="card text-white bg-dark mb-3" style="max-width: 30rem;">
		  <div class=" ">
		  	<div class="card-header">HEADERS and BODY RESPONSE
			  	<i class="fa fa-circle theIcon01" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon02" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon03" style="font-size:20px"></i>
		  	  </div>
		     </div>
		 	 <div class="card-body">
             <p>IAn HTTP response can include many headers. Each header is a line that starts with a keyword, such as Location or Content-type, followed by a colon and a value. Headers are a sort of metadata for the response. They aren't displayed by browsers or other clients; instead, they tell the client various information about the response.</p>
                 
            <p>Many, many features of the Web are implemented using headers. For instance, cookies are a Web feature that lets servers store data on the browser, for instance to keep a user logged in. To set a cookie, the server sends the Set-Cookie header. The browser will then send the cookie data back in a Cookie header on subsequent requests. You'll see more about cookies later in this course.</p>
                 
            <p class="theCode">Content-type: text/html; charset=utf-8</p>
                 
                
            <h2>Content-type</h2>
                 
		     <p class="card-text">A Content-type header indicates the kind of data that the server is sending. It includes a general category of content as well as the specific format. For instance, a PNG image file will come with the Content-type image/png. If the content is text (including HTML), the server will also tell what encoding it's written in. UTF-8 is a very common choice here, and it's the default for Python text anyway.</p>

            <p> Very often, the headers will contain more metadata about the response body. For instance, both the demo server and Google also send a Content-Length header, which tells the client how long (in bytes) the response body will be. If the server sends this, then the client can reuse the connection to send another request after it's read the first response. Browsers use this so they can fetch multiple pieces of data (such as images on a web page) without having to reconnect to the server.</p>
                 
            <h2>Body Response</h2>
                 
		     <p class="card-text">The headers end with a blank line. Everything after that blank line is part of the response body. If the request was successful (a 200 OK status, for instance), this is a copy of whatever resource the client asked for — such as a web page, image, or other pieces of data.</p>

            <p> But in the case of an error, the response body is where the error message goes! If you request a page that doesn't exist, and you get a 404 Not Found error, the actual error message shows up in the response body.</p>
                 
                 
			</div>
		</div>
    
    
    
</div>

</body>
</html>