<!DOCTYPE html>
<html>
    <head>
	<title>Tools</title>
	<link rel="stylesheet" type="text/css" href="external/css/bootstrap.css">
	<script type="text/javascript" src="./external/js/bootstrap.js" rel="javascript"></script>
    <script type="text/javascript" src="external/js/jquery.min.js" rel="javascript"></script>
  
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.16.0/umd/popper.min.js"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js"></script>

	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
	<link href="https://fonts.googleapis.com/css?family=Courier+Prime&display=swap" rel="stylesheet">
	<link rel="stylesheet" type="text/css" href="css/main.css">
	<meta charset="utf-8">
    <!--meta http-equiv="refresh" content="3.9"-->
</head>
<body>


 <nav class="navbar navbar-expand-lg navbar-dark bg-dark">
  <a class="navbar-brand" href="#">Phil Full-Stack Notes</a>
  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarTogglerDemo02" aria-controls="navbarTogglerDemo02" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

  <div class="collapse navbar-collapse" id="navbarTogglerDemo02">
    <ul class="navbar-nav mr-auto mt-2 mt-lg-0">
        
      <li class="nav-item active">
        <a class="nav-link" href="index.html">Home <span class="sr-only">(current)</span></a>
      </li>
        
      <li class="nav-item">
        <a class="nav-link" href="terminal.html">Terminal</a>
      </li>
        
        <li class="nav-item">
        <a class="nav-link" href="git.html">Git VCS</a>
      </li>
        
         <li class="nav-item">
        <a class="nav-link" href="database.html">Database</a>
      </li>
        
        <!-- Dropdown -->
    <li class="nav-item dropdown">
      <a class="nav-link dropdown-toggle" href="#" id="navbardrop" data-toggle="dropdown">
        Tools
      </a>
      <div class="dropdown-menu">
        <a class="dropdown-item" href="sql.html">SQL </a>
        <a class="dropdown-item" href="#">Boostrap 4</a>
        <a class="dropdown-item" href="#">Javascript</a>
        <a class="dropdown-item" href="httpprotocol.html">HTTP Protocol</a>
        <a class="dropdown-item" href="httpserver.html">HTTP Server</a>
        <a class="dropdown-item" href="webservice.html">WebServices</a>
      </div>
    </li>
        
         <li class="nav-item">
        <a class="nav-link" href="github.html">Git Hub</a>
      </li>
        
    </ul>
      
    <form class="form-inline my-2 my-lg-0">
      <input class="form-control mr-sm-2" type="search" placeholder="Search">
      <button class="btn btn-outline-success my-2 my-sm-0" type="submit">Search</button>
    </form>
  </div>
</nav>
    
<div class="jumbotron">
<div>
	<h1>Deploying to a Hosting Service</h1>
	<h3 class="notes">Can I just host my web service at home? </h3>
    <p> Maybe! Plenty of people do, but not everyone can. It's a common hobbyist activity, but not something that people would usually do for a job.</p>
    
    <p> There's nothing fundamentally special about the computers that run web servers. They're just computers running an operating system such as Linux, Mac OS, or Windows (usually Linux). Their connection to the Internet is a little different from a typical home or mobile Internet connection, though. A server usually needs to have a stable (static) IP address so that clients can find it and connect to it. Most home and mobile systems don't assign your computer a static IP address.</p>
    
    <p> Also, most home Internet routers don't allow incoming connections by default. You would need to reconfigure your router to allow it. This is totally possible, but way beyond the scope of this course (and I don't know what kind of router you have).</p>
    
    <p> Lastly, if you run a web service at home, your computer has to be always on.</p>
    
    <p> So, for the next exercise in this course, you'll be deploying one of your existing web services to <a href="https://www.heroku.com/" target="_blank" class="theCode">Heroku </a>, a commercial service that will host it on the web where it will be publicly accessible. </p>
    
        <div>
    <hr>
    
    </div>
    <div class="card text-white bg-dark mb-3">
       
        <h3 class="card-header"> Steps to Heroku deployment</h3>
        <ol>
            <li> Check your server code into a new local Git repository.</li>
            <li> Sign up for a free Heroku account.</li>
            <li> Download the Heroku <a href="https://devcenter.heroku.com/articles/heroku-cli"> command-line interface</a> (CLI).</li>
            <li>Authenticate the Heroku CLI with your account: <strong class="theCode"> heroku login</strong></li>
            <li>Create configuration files <strong class="theCode">Procfile </strong>, <strong class="theCode">requirements.txt</strong>, and <strong class="theCode">runtime.txt</strong> and check them into your Git repository.</li>
            <li>Modify your server to listen on a configurable port.</li>
            <li>Create your Heroku app: <strong class="theCode">heroku create your-app-name</strong> </li>
            <li>Push your code to Heroku with Git: <strong class="theCode">git push heroku master</strong> </li>
        </ol>
        
    </div>
    
    <div>
    <hr>
    
    </div>
    
    
	</div>
		
    	<div class="card text-white bg-info mb-3" style="max-width: 30rem;">
		  <div class=" ">
		  	<div class="card-header">>_. Check in your code
			  	<i class="fa fa-circle theIcon01" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon02" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon03" style="font-size:20px"></i>
		  	  </div>
		     </div>
		 	 <div class="card-body">
                 <h2> Check in your code </h2>
		     <p> Heroku (and many other web hosting services) works closely with Git: you can deploy a particular version of your code to Heroku by pushing it with the <strong class="theCode"> git push </strong> command. So in order to deploy your code, it first needs to be checked into a local Git repository.</p>
             
                 <blockquote class="blockquote">This Git repository should be separate from the one created when you downloaded the exercise code (the course-ud303 directory). Create a new directory outside of that directory and copy the bookmark server code (the file BookmarkServer.py from last lesson) into it. Then set this new directory up as a Git repository:</blockquote>
                 
                 <hr>
                                  
                 <ul>
                 <li class="theCode"> git init </li>
                 <li class="theCode"> git add BookmarkServer.py </li>
                 <li class="theCode"> git commit -m "Checking in my Bookmark server!" </li>                 
                 
                 </ul>
                 

                 <p>First, visit this link and follow the instructions to sign up for a free Heroku account:</p>
             
            <div class="theButton">  <button type="button" class="btn-lg btn-danger active "aria-pressed="true"><a href="https://signup.heroku.com/dc" class="theButton" target="_blank">SIGNUP </a></button> </div>
                 
                
		</div>
	</div>
    
    
    
    
    
		<div class="card text-white bg-dark mb-3" style="max-width: 30rem;">
		  <div class=" ">
		  	<div class="card-header">Create configuration files
			  	<i class="fa fa-circle theIcon01" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon02" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon03" style="font-size:20px"></i>
		  	  </div>
		     </div>
		 	 <div class="card-body">
		     <h5 class="card-title theCode">Create configuration files</h5>
		     <p class="card-text"> There are a few configuration files that Heroku requires for deployment, to tell its servers how to run your application. For the case of the bookmark server, I'll just give you the required content for these files. These are just plain text files and can be created in your favorite text editor. </p>
                 
            <p> <strong class="theCode"> runtime.txt </strong> tells Heroku what version of Python you want to run. <a href="https://devcenter.heroku.com/articles/python-runtimes" target="_blank">Check the currently supported runtimes in the Heroku documentation; this will change over time!</a> As of early 2020, the currently supported version of Python 3 is python-3.7.2; so this file just needs to contain the text python-3.7.2. </p>
                 
            <p><strong class="theCode">requirements.txt</strong> is used by Heroku (through <strong class="theCode">pip</strong>) to install dependencies of your application that aren't in the Python standard library. The bookmark server has one of these: the <strong class="theCode">requests</strong> module. We'd like a recent version of that, so this file can contain the text <strong class="theCode">requests>=2.12</strong>. This will install version 2.12 or a later version, if one has been released.</p>
                 
            <p><strong class="theCode">Procfile</strong> is used by Heroku to specify the command line for running your application. It can support running multiple servers, but in this case we're only going to run a web server. Check the Heroku documentation about process types for more details. If your bookmark server is in <strong class="theCode">BookmarkServer.py</strong>, then the contents of Procfile should be <strong class="theCode">web: python BookmarkServer.py</strong>.</p>
                 
            <hr>
                 
            <h3>Listen on a configurable port</h3>

            <p>There's one small change that you have to make to your server code to make it run on Heroku. The bookmark server from Lesson 2 listens on port 8000. But Heroku runs many users' processes on the same computer, and multiple processes can't (normally) listen on the same port. So Heroku needs to be able to tell your server what port to listen on.</p>
        
            <p>The way it does this is through an <strong class="theCode">environment variable</strong> — a configuration variable that is passed to your server from the program that starts it, usually the shell. Python code can access environment variables in the <strong class="theCode">os.environ</strong> dictionary. The names of environment variables are usually capitalized; and the environment variable we need here is called, unsurprisingly, <strong class="theCode">PORT</strong>.</p>
                 
            <p>The port your server listens on is configured when it creates the <strong class="theCode">HTTPServer</strong> instance, near the bottom of the server code. We can make it work with or without the <strong class="theCode">PORT</strong> environment variable, like so:</p>
                 
                 <ul>
                    <li class="theCode">if __name__ == '__main__':</li>
                        <ul>
                            <li class="theCode">port = int(os.environ.get('PORT', 8000))</li>
                            <li class="theCode">server_address = ('', port)</li>
                            <li class="theCode">httpd = http.server.HTTPServer(server_address, Shortener)</li>
                            <li class="theCode"> httpd.serve_forever()</li>
                        </ul>
                 
                 </ul>
            
            <p> To access <strong class="theCode">os.environ </strong>, you will also need to <strong class="theCode"> import os </strong>at the top of the file. </p>
                 
            <p>Make these changes to your server code, run the server locally to test that it still works, then commit it to your Git repository:</p>

                  
             <ul>
                <li class="theCode">git add BookmarkServer.py</li>
                <li class="theCode">git commit -m "Use PORT from environment."</li>
            </ul>
            
             <hr>
                 
            <h3>Create and push your app</h3>

            <p>Before you can put your service on the web, you have to give it a name. You can call it whatever you want, as long as the name is not already taken by another user! Your app's name will appear in the URI of your deployed service. For instance, if you name your app silly-pony, it will appear on the web at https://silly-pony.herokuapp.com/.</p>
        
            <p> Use <strong class="theCode">heroku create your-app-name</strong> to tell Heroku about your app and give it a name. Again, you can choose any name you like, but it will have to be unique — the service will tell you if you're choosing a name that someone else has already claimed.</p>
                 
            <p>Finally, use <strong class="theCode"> git push heroku master </strong> to deploy the app!</p>
                 
		</div>
	</div>



	<div class="card text-white bg-dark mb-3" style="max-width: 30rem;">
		  <div class=" ">
		  	<div class="card-header">Accessing server logs
			  	<i class="fa fa-circle theIcon01" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon02" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon03" style="font-size:20px"></i>
		  	  </div>
		     </div>
		 	 <div class="card-body">
		     <h5 class="card-title theCode">$python3 -m http.server 8000</h5>
                 <p class="card-text">If your app doesn't work quite right as deployed, one resource that can be very helpful is the server log. Since your service isn't running on your own local machine any more, those logs aren't going to show up in your terminal! Instead, they're available from the Heroku dashboard.</p>

                 <p>Take a look at https://dashboard.heroku.com/apps/little-bookmarks/logs, but replace "little-bookmarks" with your own app's name. </p>
		</div>
	</div>

	<div class="card text-white bg-dark mb-3" style="max-width: 30rem;">
		  <div class=" ">
		  	<div class="card-header">.encode() 
			  	<i class="fa fa-circle theIcon01" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon02" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon03" style="font-size:20px"></i>
		  	  </div>
		     </div>
		 	 <div class="card-body">
		     <h5 class="card-title theCode">self.wfile.write("Hello, HTTP!\n".encode())
 </h5>
                 <p class="card-text ">An HTTP response could contain any kind of data, not only text. And so the self.wfile.write method in the handler class expects to be given a bytes object — a piece of arbitrary binary data — which it writes over the network in the HTTP response body.</p>

                 <p>If you want to send a string over the HTTP connection, you have to encode the string into a bytes object. The encode method on strings translates the string into a bytes object, which is suitable for sending over the network. There is, similarly, a decode method for turning bytes objects into strings.</p>

                 <p>Text strings look simple, but they are actually kind of complicated underneath. There are a lot of different ways that computers can represent text in memory and on the network.</p>
                 
                 <p>lder software — including older versions of Python — tended to assume that each character takes up only one byte of memory. That works fine for some human languages, like English and Russian, but it doesn't work at all for other human languages, like Chinese; and it really doesn't work if you want to handle text from multiple languages in the same program.</p>
                 
                 <p>The Web is international, so browsers and servers need to support all languages. This means that the old one-byte assumption is completely thrown out. But when programs use the network, they need to know how long a piece of data is in terms of bytes. That has to be figured out unambiguously at some point in time. The way Python does this is by making us encode strings into bytes objects when we want to send them over a binary channel (such as an HTTP connection).</p>
                 
                 <p>UTF-8 is the default encoding in Python. When you call the encode method on a string without passing it another encoding, it assumes you mean UTF-8. This is the right thing to do, so that's what the code in this course does.</p>
                 
                 <a href="https://docs.python.org/3.6/howto/unicode.html" target="_blank"><button type="button" class="btn-lg btn-danger "s>UNICODE</button></a>
		</div>
	</div>
		
		<div class="card text-white bg-dark mb-3" style="max-width: 30rem;">
		  <div class=" ">
		  	<div class="card-header">  Path
			  	<i class="fa fa-circle theIcon01" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon02" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon03" style="font-size:20px"></i>
		  	  </div>
		     </div>
		 	 <div class="card-body">
		     
		     <p class="card-text">The only difference in the code between EchoHandler and HelloHandler is what they write in the response body. The hello server always writes the same message, while the echo server takes its message from the request path. Here's how I did it — a one-line change at the end of do_GET:</p>
                 
                 <h5 class="card-title theCode">$self.wfile.write(self.path[1:].encode())</h5>
                 
                 <p>What I'm doing here is taking the path (for instance "/bears"), using a string slice to remove the first character (which is always a slash), and then encoding the resulting string into bytes, then writing that to the HTTP response body.</p>

                 <p>message = self.path[1:]  # Extract 'bears' from '/bears', for instance </p>
                 <p>message_bytes = message.encode()  # Make bytes from the string</p>
                 <p>self.wfile.write(message_bytes)  # Send it over the network</p>

			</div>
		</div>
		
		<div class="card text-white bg-dark mb-3" style="max-width: 30rem;">
		  <div class=" ">
		  	<div class="card-header">Queries and quoting
			  	<i class="fa fa-circle theIcon01" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon02" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon03" style="font-size:20px"></i>
		  	  </div>
		     </div>
		 	 <div class="card-body">
		     <h5 class="card-title theCode">Unpacking query parameters </h5>

		      <p class="card-text">When you take a look at a URI for a major web service, you'll often see several query parameters, which are a sort of variable assignment that occurs after a ? in the URI. For instance, here's a Google Image Search URI:</p>
                 
                 <a href="#" class="theCode">https://www.google.com/search?q=gray+squirrel&tbm=isch</a>

                 <p> This will be sent to the web server as this HTTP request:</p>
                 
                 <p class="theCode">GET /search?q=gray+squirrel&tbm=isch HTTP/1.1</p>
                 <p class="theCode">Host: www.google.com</p>
                 
                 <p>The query part of the URI is the part after the ? mark. Conventionally, query parameters are written as key=value and separated by <strong class="theCode">&amp;</strong> signs. So the above URI has two query parameters, q and tbm, with the values gray+squirrel and isch.</p>
                 
                 <p>(isch stands for Image Search.)</p>
                 
                 <p>There is a Python library called urllib.parse that knows how to unpack query parameters and other parts of an HTTP URL. (The library doesn't work on all URIs, only on some URLs.)</p>
                 
                 <a href="https://docs.python.org/3/library/urllib.parse.html" target="_blank"><button type="button" class="btn-lg btn-danger "s>urllib.parse</button></a>
                 
                 
                 <p>A query parameter may show up multiple times in the query string, so parse_qs returns a dictionary of lists with all the values it's associated with.</p>
                 
                 <p class="theCode">>>> from urllib.parse import urlparse, parse_qs</p>
                 <p class="theCode">>>> address = 'https://www.google.com/search?q=gray+squirrel&tbm=isch'</p>
                 <p class="theCode">>>> parts = urlparse(address)</p>
                 <p class="theCode">>>> print(parts)</p>
                 
                 <p>As a result you will get:</p>
                 
                 <blockquote class="blockquote">
                 ParseResult(scheme='https', netloc='www.google.com', path='/search', params='', query='q=gray+squirrel&tbm=isch', fragment='')
                 </blockquote>
                 
                 <p>Then</p>
                 
                 <p class="theCode">>>> print(parts.query)</p>
                 
                 <p>And will get:</p>
                 <blockquote class="blockquote">
                 q=gray+squirrel&tbm=isch
                 </blockquote>
                 
                 
                 <p class="theCode">>>>query = parse_qs(parts.query)</p>
                 <p class="theCode">>>> query </p>
                 <p class="theCode">{'q': ['gray squirrel'], 'tbm': ['isch']}</p>
                 
                  <p> As a result, you are getting a dictionary with the values passed in the Url:</p>

                  <blockquote class="blockquote">{'q': ['gray squirrel'], 'tbm': ['isch']}</blockquote>
                 
                 <p>If you want to read each parameter you can use:</p>
                 
                 <p class="theCode">>>>query['q']</p>
                 
                 <p>To get as the result: ['gray squirrel']</p>
                 
                 
                 

		</div>
	</div>

	<div class="card text-white bg-dark mb-3" style="max-width: 30rem;">
		  <div class=" ">
		  	<div class="card-header"> URI Quoting
			  	<i class="fa fa-circle theIcon01" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon02" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon03" style="font-size:20px"></i>
		  	  </div>
		     </div>
		 	 <div class="card-body">
		     <h5 class="card-title">URI Quoting </h5>
		     <p class="card-text">Did you notice that 'gray+squirrel' in the query string became 'gray squirrel' in the output of parse_qs?</p>
                 
                 <p>HTTP URLs aren't allowed to contain spaces or certain other characters. So if you want to send these characters in an HTTP request, they have to be translated into a "URL-safe" or "URL-quoted" format.</p>

                 <p>"Quoting" in this sense doesn't have to do with quotation marks, the kind you find around Python strings. It means translating a string into a form that doesn't have any special characters in it, but in a way that can be reversed (unquoted) later.</p>

                 <p>(And if that isn't confusing enough, it's sometimes also referred to as URL-encoding or URL-escaping).</p>

                 <p>One of the features of the URL-quoted format is that spaces are sometimes translated into plus signs. Other special characters are translated into hexadecimal codes that begin with the percent sign.</p>

                 <p>Take a look at the documentation for urllib.parse.quote and related functions.</p>

                <p>Later in the course when you want to construct a URI in your code, you'll need to use appropriate quoting. More generally, whenever you're working on a web application and you find spaces or percent-signs in places you don't expect them to be, it means that something needs to be quoted or unquoted. </p>

			</div>
		</div>

	<div class="card text-white bg-dark mb-3" style="max-width: 30rem;">
		  <div class=" ">
		  	<div class="card-header">POST METHOD
			  	<i class="fa fa-circle theIcon01" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon02" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon03" style="font-size:20px"></i>
		  	  </div> 
		     </div>
		 	 <div class="card-body">
		     <h5 class="card-title theCode">Form methods: GET and POST </h5>
		     <p class="card-text">In the last lesson, I mentioned that GET is only one of many HTTP verbs or methods.</p>

                 <p>When a browser submits a form via GET, it puts all of the form fields into the URI that it sends to the server. These are sent as a query, in the request path — just like search engines do. They're all jammed together into a single line. Since they're in the URI, the user can bookmark the resulting page, reload it, and so forth.
		      </p>
                 
                 <p>This is fine for search engine queries, but it's not quite what we would want for (say) a form that adds an item to your shopping cart on an e-commerce site, or posts a new message on a comments board. GET methods are good for search forms and other actions that are intended to look something up or ask the server for a copy of some resource. But GET is not recommended for actions that are intended to alter or create a resource. For this sort of action, HTTP has a different verb, POST.</p>
                 
                <h3>Idempotence</h3>

                 
                 <blockquote class="blockquote">
                    <p>Vocabulary word of the day: idempotent. An action is idempotent if doing it twice (or more) produces the same result as doing it once. "Show me the search results for 'polar bear'" is an idempotent action, because doing it a second time just shows you the same results. "Add a polar bear to my shopping cart" is not, because if you do it twice, you end up with two polar bears.</p>

                    <p> POST requests are not idempotent. If you've ever seen a warning from your browser asking you if you really mean to resubmit a form, what it's really asking is if you want to do a non-idempotent action a second time.</p>
                 
                 </blockquote>
                 
                 <p>(Important note if you're ever asked about this in a job interview: idempotent is pronounced like "eye-dem-poe-tent", or rhyming with "Hide 'em, Joe Tent" — not like "id impotent".)</p>
                 
                 <p>When a browser submits a form as a POST request, it doesn't encode the form data in the URI path, the way it does with a GET request. Instead, it sends the form data in the request body, underneath the headers. The request also includes Content-Type and Content-Length headers, which we've previously only seen on HTTP responses.</p>
                 
                 <blockquote class="blockquote">By the way, the names of HTTP headers are case-insensitive. So there's no difference between writing Content-Length or content-length or even ConTent-LeNgTh … except, of course, that humans will read your code and be confused by that last one.</blockquote>

			</div>
		</div>
    
    <div class="card text-white bg-dark mb-3" style="max-width: 30rem;">
		  <div class=" ">
		  	<div class="card-header">A server for POST
			  	<i class="fa fa-circle theIcon01" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon02" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon03" style="font-size:20px"></i>
		  	  </div>
		     </div>
		 	 <div class="card-body">
		     <h5 class="card-title theCode">A server for POST </h5>
                 <p class="card-text">n the next few exercises, you'll be building a messageboard server. </p>

                 <p>When a user goes to the main page in their browser, it'll display a form for writing messages, as well as a list of the previously written messages.</p>

                 <p>Submitting the form will send a request to the server, which stores the submitted message and then re-displays the main page.</p>

                 <p>In order to test your messageboard server, you'll need to install the requests module, which is a Python module for making HTTP requests.</p>

                <p>We'll see much more about this module later in this lesson. For now, just run <strong class="theCode">pip3 install requests</strong> in your terminal to install it.
		      </p>
                 
                 <p>We'll be using a GET request to display the messageboard's existing contents, and POST to update the contents by creating new messages. Creating new messages is not idempotent — we don't want duplicates.</p>
                 
                 
                 <h3>Why don't we want to use GET for submitting the form?</h3>
                 
                 <p> Imagine if a user did this. They write a message and press the submit button … and the message text shows up in their URL bar. If they press reload, it sends the message again. If they bookmark that URL and go back to it, it sends the message again.</p>

                 <p>This doesn't seem like such a great experience. So we'll use POST for message submission, and GET to display the main page.</p>
                 
                 <hr>
                 
                 <h3>POST handlers read the request body</h3>
                 
                 <p>Previously in the HelloServer exercise, you've written handler classes that have just a single method, do_GET.</p>

                 <p>But a handler class can have do_POST as well, to support GET and POST requests. This is exactly how the messageboard server will work.</p>

                 <p>When a GET request comes in, the server will send the HTML form and current messages. When a POST request comes in with a new message, the server will store the message in a list, and then return all the messages it's seen so far.</p>

                 <p>The code for a do_POST method will need to do some pretty different things from a do_GET method. When we're handling a GET request, all the user data in the request is in the URI path. But in a POST request, it's in the request body.</p>

                 <p>Inside do_POST, our code can read the request body by calling the self.rfile.read method. self.rfile is a file object, like the self.wfile we saw earlier — but rfile is for reading the request, rather than writing the response.</p>

                 <p>However, self.rfile.read needs to be told how many bytes to read … in other words, how long the request body is.</p>
                 
                <p>If there's a request body at all, the browser will send the length of the request body in the Content-Length header.</p>

			</div>
		</div>
    
    <div class="card text-white bg-dark mb-3" style="max-width: 30rem;">
		  <div class=" ">
		  	<div class="card-header">Headers are strings (or missing)
			  	<i class="fa fa-circle theIcon01" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon02" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon03" style="font-size:20px"></i>
		  	  </div>
		     </div>
		 	 <div class="card-body">
		     <h5 class="card-title theCode">Still under POST </h5>
		     <p class="card-text">The handler class gives us access to the HTTP headers as the instance variable self.headers, which is an object that acts a lot like a Python dictionary. The keys of this dictionary are the header names, but they're case-insensitive: it doesn't matter if you look up 'content-length' or 'Content-Length'. The values in this dictionary are strings: if the request body is 140 bytes long, the value of the Content-length entry will be the string "140". We need to call self.rfile.read(140) to read 140 bytes; so once we read the header, we'll need to convert it to an integer.</p>

                <p>But in an HTTP request, it's also possible that the body will be empty, in which case the browser might not send a Content-length header at all. This means we have to be a little careful when accessing the headers from the self.headers object. If we do self.headers['content-length'] and there's no such header, our code will crash with a KeyError. Instead, we'll use the .get dictionary method to get the header value safely.</p>

                 <p>So here's a little bit of code that can go in the do_POST handler to find the length of the request body and read it:
		      </p>
                 
                 <p class="theCode">length = int(self.headers.get('Content-length', 0))</p>
                <p class="theCode">data = self.rfile.read(length).decode()</p>
                 
                 <blockquote class="blockquote">
                 Once you read the message body, you can use urllib.parse.parse_qs to extract the POST parameters from it.
                 </blockquote>
                

			</div>
		</div>
    
    <div class="card text-white bg-dark mb-3" style="max-width: 30rem;">
		  <div class=" ">
		  	<div class="card-header">Post-Redirect-Get
			  	<i class="fa fa-circle theIcon01" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon02" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon03" style="font-size:20px"></i>
		  	  </div>
		     </div>
		 	 <div class="card-body">
		     <h5 class="card-title theCode"> &lt;a href="cliffsofinsanity.png"&gt;cliffsofinsanity.png&lt;/a&gt;</h5>
		     <p class="card-text">There's a very common design pattern for interactive HTTP applications and APIs, called the PRG or Post-Redirect-Get pattern. A client POSTs to a server to create or update a resource; on success, the server replies not with a 200 OK but with a 303 redirect. The redirect causes the client to GET the created or updated resource.</p>

             <p>This is just one of many, many ways to architect a web application, but it's one that makes good use of HTTP methods to accomplish specific goals. For instance, wiki sites such as Wikipedia often use Post-Redirect-Get when you edit a page.</p>
                 
            <p>For the messageboard server, Post-Redirect-Get means:</p>
            <ol>
                <li>You go to http://localhost:8000/ in your browser. Your browser sends a GET request to the server, which replies with a 200 OK and a piece of HTML. You see a form for posting comments, and a list of the existing comments. (But at the beginning, there are no comments posted yet.) </li>
                <li>You write a comment in the form and submit it. Your browser sends it via POST to the server.</li>
                <li>The server updates the list of comments, adding your comment to the list. Then it replies with a 303 redirect, setting the Location: / header to tell the browser to request the main page via GET.</li>
                <li>The redirect response causes your browser to go back to the same page you started with, sending a GET request, which replies with a 200 OK and a piece of HTML …</li>
                 
            </ol>
                <p>One big advantage of Post-Redirect-Get is that as a user, every page you actually see is the result of a GET request, which means you can bookmark it, reload it, and so forth — without ever accidentally resubmitting a form.</p>
                 
			</div>
		</div>
    
    
        <div class="card text-white bg-dark mb-3" style="max-width: 30rem;">
		  <div class=" ">
		  	<div class="card-header">Making requests
			  	<i class="fa fa-circle theIcon01" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon02" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon03" style="font-size:20px"></i>
		  	  </div>
		     </div>
		 	 <div class="card-body">
                <p class="theCode"> requests.get("http://localhost:8000/")</p>
                 
                 <p>The requests function for performing GET requests is requests.get, and it takes the URI as an argument.</p>
                 
                    <p>The requests library is a Python library for sending requests to web servers and interpreting the responses. It's not included in the Python standard library, though; you'll need to install it. In your terminal, run pip3 install requests to fetch and install the requests library.</p>
                 
		         <a href="https://2.python-requests.org//en/master/user/quickstart/" target="_blank"><button type="button" class="btn-lg btn-danger "s>Requests</button></a>
                <hr>
                
		     <p class="card-text">If you follow these links in your browser, it will fetch the same page from Wikipedia's web server. But the second one displays the page scrolled to the section about the discovery of oxygen. The part of the URI after the <strong class="theCode">#</strong> sign is called a <strong class="theCode">fragment</strong>. The browser doesn't even send it to the web server. It lets a link point to a specific named part of a resource; in HTML pages it links to an element by id.</p>
                 
                 <p>In contrast, consider this Google Search URI:</p>
                 
                 <ul>
                     <li class="theCode">>>> import requests
                     <li class="theCode">>>> a = requests.get("http://udacity.com")</li>
                     <li class="theCode">>>> a</li>
                     <li class="theCode">Response [200]</li>
                     <li class="theCode">>>> type(a)</li>
                     <li class="theCode"> class 'requests.models.Response'</li>            
                 </ul>
                 
                
                 <h3>r.content or r.text</h3>
                 <p>Both, but they're different. r.content is a bytes object representing the literal binary data that the server sent. r.text is the same data but interpreted as a str object, a Unicode string.</p>
                 
                 
                 <h3>Handling errors</h3>
                 
                 <p>If the requests.get call can reach an HTTP server at all, it will give you a Response object. If the request failed, the Response object has a status_code data member — either 200, or 404, or some other code.</p>

                 <p>But if it wasn't able to get to an HTTP server, for instance because the site doesn't exist, then requests.get should raise an exception.</p>

                 <p>However: Some Internet service providers will try to redirect browsers to an advertising site if you try to access a site that doesn't exist. This is called DNS hijacking, and it's nonstandard behavior, but some do it anyway. If your ISP hijacks DNS, you won't get exceptions when you try to access nonexistent sites. Standards-compliant DNS services such as Google Public DNS don't hijack.</p>
                 
			</div>
		</div>
    
    <div class="card text-white bg-dark mb-3" style="max-width: 30rem;">
		  <div class=" ">
		  	<div class="card-header">Using a JSON API
			  	<i class="fa fa-circle theIcon01" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon02" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon03" style="font-size:20px"></i>
		  	  </div>
		     </div>
		 	 <div class="card-body">
            <h5 class="card-title theCode">Using a JSON API </h5>
                 
                 <p>As a web developer, you will deal with data in a lot of different formats, especially when your code calls out to APIs provided by other developers. It's not uncommon for a large software system to have parts that deal with a dozen or more different data formats. Fortunately, usually, someone else has already written libraries to help you read and write these formats.</p>
                 
                 
		          <p class="card-text">JSON is a data format based on the syntax of JavaScript, often used for web-based APIs. There are a lot of services that let you send HTTP queries and get back structured data in JSON format. You can read more about the JSON format at http://www.json.org/.</p>

                 <p>Python has a built-in json module; and as it happens, the requests module makes use of it. A Response object has a .json method; if the response data is JSON, you can call this method to translate the JSON data into a Python dictionary.</p>

                 <p>Try it out! Here, I'm using it to access the Star Wars API, a classic JSON demonstration that contains information about characters and settings in the Star Wars movies:</p>
                 
                 <p class="theCode">>>> a = requests.get('http://swapi.co/api/people/1/')</p>
                 <p class="theCode">>>> a.json()['name']</p>
                 <p class="theCode">'Luke Skywalker'</p>
                 
                 <hr>
                 
                 <h2>Extract data from a JSON response</h2>
                 
                 <p>There's a great example of an API on the site http://uinames.com/, a service that makes up fake names and user account information. You can find the full API documentation under the little menu at the top right.</p>

                 <p>For this exercise, all you'll need is this URI and a couple of query parameters:</p>

                 <p class="theCode">http://uinames.com/api/</p>

                 <p>The query parameters to use are ext, which gives you a record with more fields, and region, which lets you specify which country you want your imaginary person to come from. For instance, to have the API invent a person from Italy:</p>

                 <p class="theCode">http://uinames.com/api?ext&region=Italy</p>

                 <p>(It's not perfect. For instance, currently it makes up North American phone numbers for everyone, regardless of where they live.)</p>
                 
                 <hr>
                 
			</div>
		</div>
    
     <div class="card text-white bg-dark mb-3" style="max-width: 30rem;">
		  <div class=" ">
		  	<div class="card-header">The bookmark server
			  	<i class="fa fa-circle theIcon01" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon02" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon03" style="font-size:20px"></i>
		  	  </div>
		     </div>
		 	 <div class="card-body">
                 <p>You're almost to the end of this lesson! One more server to write …</p>

                 <p>You've probably seen URL-shortening services such as TinyURL.</p>

                 <p>They let you create short URI paths like https://tinyurl.com/jye5r6l that redirect to a longer URI on another site. It's easier to put a short URI into an email, text message, or tweet. In this exercise, you'll be writing a service similar to this.</p>

                 <p>Like the messageboard server, this bookmark server will keep all of its data in memory. This means that it'll be reset if you restart it.</p>

                 <p>Your server needs to do three things, depending on what kind of request it receives: </p>
                 
                 <ul>
                     <li>On a GET request to the / path, it displays an HTML form with two fields. One field is where you put the long URI you want to shorten. The other is where you put the short name you want to use for it. Submitting this form sends a POST to the server.</li>
                     
                     <li>On a POST request, the server looks for the two form fields in the request body. If it has those, it first checks the URI with requests.get to make sure that it actually exists (returns a 200).</li>
                     
                     <ul>
                        <li>If the URI exists, the server stores a dictionary entry mapping the short name to the long URI, and returns an HTML page with a link to the short version. </li>
                        <li>If the URI doesn't actually exist, the server returns a 404 error page saying so. </li>
                        <li>If either of the two form fields is missing, the server returns a 400 error page saying so.</li>
                     </ul>
                     
                     <li>On a GET request to an existing short URI, it looks up the corresponding long URI and serves a redirect to it.</li>
                 </ul>
                 
                 
                 <hr>
                 
                 <h2>Exercise: Send a request manually</h2>
                 
                 <p>You can use ncat to connect to the demo server and send it an HTTP request by hand. (Make sure the demo server is still running!)</p>
                 
                 <p>Use <strong class="theCode"> $python3 -m http.server 8000  </strong> in your terminal to run the demo server.</p>
                 <p>Use <strong class="theCode"> $ncat 127.0.0.1 8000 </strong> (in a second ternimal)to connect your terminal to the demo server.</p>
                 
                 <p> Type the following and dopple press Enter afterwards</p>
                 <p>GET / HTTP/1.1</p>
                 <p>Host: localhost</p>
                 
                 <hr>
                 <h2>Results of the Request</h2>
                 <ul>
                    <li>HTTP/1.0 200 OK</li>
                    <li>Server: SimpleHTTP/0.6 Python/3.7.5 </li>
                    <li>Date: Sun, 05 Jan 2020 00:21:50 GMT</li>
                    <li>Content-type: text/html</li>
                    <li>Content-Length: 127</li>
                    <li>Last-Modified: Sat, 04 Jan 2020 21:46:26 GMT</li>
                    <li>and an HTML code</li>
                 </ul>
                 
                 
                 
			</div>
		</div>
    
    <div class="card text-white bg-dark mb-3" style="max-width: 30rem;">
		  <div class=" ">
		  	<div class="card-header">HTTP Response
			  	<i class="fa fa-circle theIcon01" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon02" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon03" style="font-size:20px"></i>
		  	  </div>
		     </div>
		 	 <div class="card-body">
             <p>After you typed Host: localhost and pressed Enter twice, the server sent back a lot of text. This is an HTTP response. One of these exchanges — a request and response — is happening every time your browser asks a server for a page, an image, or anything else. </p>
                 
            <p>Here's another one to try. Use ncat to connect to google.com port 80, and send a request for the path / on the host google.com:</p>
                 
                 <p>GEGT / HTTP/1.1</p>
                 <p>Host: google.com</p>

                 
                 
            <h2>HTTP RESPONSE </h2>
                
            <p>The HTTP response is made up of three parts: </p>
                 <ul>
                     <li> the status line</li>
                     <li> some headers</li>
                     <li> a response body</li>
                 </ul>
                 
		     <p class="card-text">The status line is the first line of text that the server sends back. The headers are the other lines up until the first blank line. The response body is the rest — in this case, it's a piece of HTML.</p>

                 
                 
			</div>
		</div>
    
    
    
        <div class="card text-white bg-dark mb-3" style="max-width: 30rem;">
		  <div class=" ">
		  	<div class="card-header">STATUS LINE
			  	<i class="fa fa-circle theIcon01" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon02" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon03" style="font-size:20px"></i>
		  	  </div>
		     </div>
		 	 <div class="card-body">
             <p>In the response you got from your demo server, the status line said <strong class="theCode">HTTP/1.0 200 OK</strong>. In the one from Google, it says <strong class="theCode">HTTP/1.1 301 Moved Permanently </strong>. The status line tells the client whether the server understood the request, whether the server has the resource the client asked for, and how to proceed next. It also tells the client which dialect of HTTP the server is speaking.</p>
                 
            <p>The numbers 200 and 301 here are HTTP status codes. There are dozens of different status codes. The first digit of the status code indicates the general success of the request. As a shorthand, web developers describe all of the codes starting with 2 as "2xx" codes, for instance — the x's mean "any digit".</p>
                 
                
            <p>The STATUS CODES: </p>
                 <ul>
                     <li> <strong class="theCode">1xx — Informational.</strong> The request is in progress or there's another step to take.</li> 
                     <li> <strong class="theCode">2xx — Success! </strong> The request succeeded. The server is sending the data the client asked for.</li>
                     <li> <strong class="theCode">3xx — Redirection. </strong> The server is telling the client a different URI it should redirect to. The headers will usually contain a Location header with the updated URI. Different codes tell the client whether a redirect is permanent or temporary.</li>
                     <li> <strong class="theCode">4xx — Client error. </strong> The server didn't understand the client's request, or can't or won't fill it. Different codes tell the client whether it was a bad URI, a permissions problem, or another sort of error.</li>
                     <li> <strong class="theCode">5xx — Server error. </strong> Something went wrong on the server side.</li>
                     
                 </ul>
                 
		     <p class="card-text">The server response here is an example of good user interface on the Web. Google wants browsers to use www.google.com instead of google.com. But instead of showing the user an error message, they send a redirect. Browsers will automatically follow the redirect and end up on the right site.</p>

                 
                 
			</div>
		</div>
    
    
        <div class="card text-white bg-dark mb-3" style="max-width: 30rem;">
		  <div class=" ">
		  	<div class="card-header">HEADERS and BODY RESPONSE
			  	<i class="fa fa-circle theIcon01" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon02" style="font-size:20px"></i>
			  	<i class="fa fa-circle theIcon03" style="font-size:20px"></i>
		  	  </div>
		     </div>
		 	 <div class="card-body">
             <p>IAn HTTP response can include many headers. Each header is a line that starts with a keyword, such as Location or Content-type, followed by a colon and a value. Headers are a sort of metadata for the response. They aren't displayed by browsers or other clients; instead, they tell the client various information about the response.</p>
                 
            <p>Many, many features of the Web are implemented using headers. For instance, cookies are a Web feature that lets servers store data on the browser, for instance to keep a user logged in. To set a cookie, the server sends the Set-Cookie header. The browser will then send the cookie data back in a Cookie header on subsequent requests. You'll see more about cookies later in this course.</p>
                 
            <p class="theCode">Content-type: text/html; charset=utf-8</p>
                 
                
            <h2>Content-type</h2>
                 
		     <p class="card-text">A Content-type header indicates the kind of data that the server is sending. It includes a general category of content as well as the specific format. For instance, a PNG image file will come with the Content-type image/png. If the content is text (including HTML), the server will also tell what encoding it's written in. UTF-8 is a very common choice here, and it's the default for Python text anyway.</p>

            <p> Very often, the headers will contain more metadata about the response body. For instance, both the demo server and Google also send a Content-Length header, which tells the client how long (in bytes) the response body will be. If the server sends this, then the client can reuse the connection to send another request after it's read the first response. Browsers use this so they can fetch multiple pieces of data (such as images on a web page) without having to reconnect to the server.</p>
                 
            <h2>Body Response</h2>
                 
		     <p class="card-text">The headers end with a blank line. Everything after that blank line is part of the response body. If the request was successful (a 200 OK status, for instance), this is a copy of whatever resource the client asked for — such as a web page, image, or other pieces of data.</p>

            <p> But in the case of an error, the response body is where the error message goes! If you request a page that doesn't exist, and you get a 404 Not Found error, the actual error message shows up in the response body.</p>
                 
                 
			</div>
		</div>
    
    
    
</div>

</body>
</html>